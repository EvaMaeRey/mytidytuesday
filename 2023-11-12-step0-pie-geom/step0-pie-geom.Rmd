---
title: "geom_pie and geom_wedge via StatPie and StatWedge"
author: "Evangeline Reynolds"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(tidyverse.quiet = TRUE)
```

## intro...

I tried borrowing from geom_bar in https://github.com/EvaMaeRey/ggpie, but it's not the best, I think new stats might be the best way forward.

## Part 1. geom_pie... An implementation in polar coordinates with geom rect, where total count changes the size of the pie.

### Step 0.  Get job done with base ggplot2

```{r cars}
library(tidyverse)
ggplot2::diamonds %>% 
  mutate(weight = 1) %>% 
  count(cut, wt = weight) %>% 
  mutate(cum_n = cumsum(n)) %>% 
  mutate(cum_prop = cum_n/sum(n)) %>% 
  mutate(ymin = lag(cum_prop)) %>% 
  mutate(ymin = replace_na(ymin, 0)) %>% 
  mutate(r = sqrt(sum(n)/pi)) %>% 
  mutate(r0 = 0) %>% 
  ggplot() + 
  aes(x = 0, y = 0, 
      xmin = 0, ymin = ymin, 
      xmax = r, 
      ymax = cum_prop) + 
  geom_rect() + 
  aes(fill = cut) + 
  coord_polar(theta = "y")

layer_data()
```


### Step 12&3. compute, ggproto, geom_*,

```{r, error=TRUE}
compute_panel_pie <- function(data, scales){
  
  data %>% 
  count(fill) %>% 
  mutate(cum_n = cumsum(n)) %>% 
  mutate(xmax = cum_n/sum(n)) %>% 
  mutate(xmin = lag(xmax)) %>% 
  mutate(xmin = replace_na(xmin, 0)) %>% 
  mutate(r = sqrt(sum(n)/pi)) %>% 
  mutate(r0 = 0) %>% 
  mutate(x = 0, y = 0, 
         ymin = 0, ymax = r
         )
  
}

StatPie <- ggproto(`_class` = "StatPie",
                  `_inherit` = ggplot2::Stat,
                  required_aes = "fill",
                  compute_panel = compute_panel_pie,
                  default_aes = aes(group = after_stat(fill))
                  )

geom_pie <- function(
  mapping = NULL,
  data = NULL,
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatPie,  # proto object from step 2
    geom = ggplot2::GeomRect,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```

### Step 4. Test it out


```{r}
ggplot2::diamonds %>% 
  ggplot() + 
  aes(fill = cut) + 
  geom_pie() 

last_plot() + 
  coord_polar()

last_plot() +
  facet_wrap(~color) + 
  coord_cartesian()

last_plot() + 
  coord_polar()

Titanic %>% 
  data.frame() %>% 
  uncount(Freq) %>% 
  ggplot() + 
  coord_polar() + 
  aes(fill = Sex) +
  geom_pie() + 
  facet_wrap(~Sex) + 
  aes(fill = Class) + 
  facet_grid(Sex~Class) + 
  aes(fill = Survived) + 
  theme_void() +
  facet_wrap(~Sex)


Titanic %>% 
  data.frame() %>% 
  uncount(Freq) %>% 
  ggplot() + 
  coord_polar() + 
  aes(fill = Sex) +
  geom_pie() + 
  facet_wrap(~Sex) + 
  aes(fill = Class)


```


## Part 2. geom_wedge And now in cartesian coordinates...

### Step 0. W/ base ggplot2

```{r}
num_in_arc <- 5

library(tidyverse)
ggplot2::diamonds %>% 
  count(cut) %>% 
  mutate(cum_n = cumsum(n)) %>% 
  mutate(cum_prop = cum_n/sum(n)) %>% 
  mutate(ymin = lag(cum_prop)) %>% 
  mutate(ymin = replace_na(ymin, 0)) %>% 
  mutate(r = sqrt(sum(n)/pi)) %>% 
  mutate(r0 = 0) %>% 
  crossing(id_arc_point = c(-1:(num_in_arc + 1))) %>% 
  mutate(pos_in_radians = 2*pi*(ymin + (cum_prop - ymin)/num_in_arc*id_arc_point )) %>% 
  mutate(x = r*cos(pos_in_radians)) %>% 
  mutate(y = r*sin(pos_in_radians)) %>% 
  mutate(x = ifelse(id_arc_point == -1 | 
                      id_arc_point == num_in_arc + 1, 0, x)) %>% 
  mutate(y = ifelse(id_arc_point == -1 | 
                      id_arc_point == num_in_arc + 1, 0, y)) %>% 
  ggplot() + 
  aes(x = x, y = y ) + 
  geom_polygon() + 
  aes(fill = cut) + 
  aes(color = cut) + 
  geom_point() + 
  coord_equal()
```

### Step 123 (compute, ggproto, geom_*)

```{r error = T}
compute_panel_wedge <- function(data, scales){
  
  data %>% 
  count(fill) %>% 
  mutate(cum_n = cumsum(n)) %>% 
  mutate(cum_prop = cum_n/sum(n)) %>% 
  mutate(ymin = lag(cum_prop)) %>% 
  mutate(ymin = replace_na(ymin, 0)) %>% 
  mutate(r = sqrt(sum(n)/pi)) %>% 
  mutate(r0 = 0) %>% 
  crossing(id_arc_point = c(-1:(num_in_arc + 1))) %>% 
  mutate(pos_in_radians = 2*pi*(ymin + (cum_prop - ymin)/num_in_arc*id_arc_point )) %>% 
  mutate(x = cos(pos_in_radians)) %>% 
  mutate(y = sin(pos_in_radians)) %>% 
  mutate(x = ifelse(id_arc_point == -1 | id_arc_point == num_in_arc + 1, 0, x)) %>% 
  mutate(y = ifelse(id_arc_point == -1 | id_arc_point == num_in_arc + 1, 0, y))
  
  
  
}


StatWedge <- ggproto(`_class` = "StatWedge",
                  `_inherit` = ggplot2::Stat,
                  required_aes = "fill",
                  compute_panel = compute_panel_wedge,
                  default_aes = aes(group = after_stat(fill)))

geom_wedge <- function(
  mapping = NULL,
  data = NULL,
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatPie,  # proto object from step 2
    geom = ggplot2::GeomPolygon,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```

### Step 4. Test it out (failing)

```{r warning=T, error= T, message = T}
diamonds %>% 
ggplot() + 
  aes(fill = cut) + 
  geom_wedge()
```

## Closing remarks, Other Relevant Work, Caveats

Need to work on labeling strategy!

