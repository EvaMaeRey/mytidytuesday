<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.0.23">
<title></title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils/css/prism-xcode.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.12.14/css/default.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.12.14/css/article.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.12.14/css/book.min.css">
</head>
<body>
<div class="frontmatter">
<div class="title"><h1></h1></div>
<div class="author"><h2></h2></div>
<div class="date"><h3></h3></div>
</div>
<div class="">
<div id="TOC">
<ul class="numbered">
<li><a href="#sec-ggplot2-extension-cookbook"><span class="section-number main-number">1</span> ggplot2-extension-cookbook</a></li>
<li><a href="#sec-preface-and-acknowledgements"><span class="section-number main-number">2</span> Preface and acknowledgements</a></li>
<li><a href="#sec-getting-started"><span class="section-number main-number">3</span> Getting started</a></li>
<li><a href="#sec-easy-geom-functions-writing-new-definitions-for-where-and-how-of-marks-on-ggplots"><span class="section-number main-number">4</span> easy geom_* functions: writing new definitions for where and how of marks on ggplots</a>
<ul>
<li><a href="#sec-geom-text-coordinate-1-1-1-compute-group-geomtext"><span class="section-number">4.1</span> geom_text_coordinate: <strong>1:1:1, compute_group, GeomText</strong></a>
<ul>
<li><a href="#sec-step-0-use-base-ggplot2_1"><span class="section-number">4.1.1</span> Step 0: use base ggplot2</a></li>
<li><a href="#sec-step-1-compute_1"><span class="section-number">4.1.2</span> Step 1: Compute</a></li>
<li><a href="#sec-step-2-pass-to-ggproto-object_1"><span class="section-number">4.1.3</span> Step 2: pass to ggproto object</a></li>
<li><a href="#sec-step-3-write-user-facing-function_1"><span class="section-number">4.1.4</span> Step 3. Write user facing function.</a></li>
<li><a href="#sec-step-4-use-test-enjoy_1"><span class="section-number">4.1.5</span> Step 4: Use/test/enjoy</a></li>
</ul>
</li>
<li><a href="#sec-geom-post-1-1-1-compute-group-geomsegment"><span class="section-number">4.2</span> geom_post: <strong>1:1:1, compute_group, GeomSegment</strong></a>
<ul>
<li><a href="#sec-step-0-use-base-ggplot2_2"><span class="section-number">4.2.1</span> Step 0. Use base ggplot2</a></li>
<li><a href="#sec-step-1-compute_2"><span class="section-number">4.2.2</span> Step 1:  Compute</a></li>
<li><a href="#sec-step-2-pass-to-ggproto_1"><span class="section-number">4.2.3</span> Step 2: Pass to ggproto</a></li>
<li><a href="#sec-step-3-pass-to-user-facing-function-using-ggplot2-layer"><span class="section-number">4.2.4</span> Step 3: Pass to user-facing function using ggplot2::layer()</a></li>
<li><a href="#sec-step-4-use-test-enjoy_2"><span class="section-number">4.2.5</span> Step 4: use/test/enjoy</a></li>
<li><a href="#sec-geom-lollipop-tangential-bonus-topic-combining-layers-into-single-geom-function"><span class="section-number">4.2.6</span> geom_lollipop: Tangential bonus topic: Combining layers into single geom_*() function</a></li>
</ul>
</li>
<li><a href="#sec-geom-xy-means-n-1-1-compute-group-geompoint"><span class="section-number">4.3</span> geom_xy_means: <strong>n:1:1, compute_group, GeomPoint</strong></a>
<ul>
<li><a href="#sec-step-0-use-base-ggplot2_3"><span class="section-number">4.3.1</span> Step 0.  Use base ggplot2</a></li>
<li><a href="#sec-step-1-write-compute-function_1"><span class="section-number">4.3.2</span> Step 1. Write compute function</a></li>
<li><a href="#sec-step-2-define-stat-pasing-in-compute"><span class="section-number">4.3.3</span> Step 2. Define Stat, pasing in compute</a></li>
<li><a href="#sec-step-3-write-user-facing-function_2"><span class="section-number">4.3.4</span> Step 3. Write user-facing function</a></li>
<li><a href="#sec-step-4-use-test-enjoy_3"><span class="section-number">4.3.5</span> Step 4. Use/Test/Enjoy</a></li>
</ul>
</li>
<li><a href="#sec-geom-chull-n-1-n-compute-group-geompolygon"><span class="section-number">4.4</span> geom_chull: <strong>N:1:n, compute_group, GeomPolygon</strong></a>
<ul>
<li><a href="#sec-step-0-get-it-done-with-ggplot2"><span class="section-number">4.4.1</span> Step 0. get it done with ggplot2</a></li>
<li><a href="#sec-step-1-compute_3"><span class="section-number">4.4.2</span> Step 1. Compute</a></li>
<li><a href="#sec-step-2-pass-to-ggproto_2"><span class="section-number">4.4.3</span> Step 2. Pass to ggproto</a></li>
<li><a href="#sec-step-3-write-user-facing-geom-stat-function-s"><span class="section-number">4.4.4</span> Step 3. Write user-facing geom_/stat_ Function(s)</a></li>
<li><a href="#sec-step-4-try-out-test-enjoy"><span class="section-number">4.4.5</span> Step 4. Try out/test/ enjoy</a></li>
</ul>
</li>
<li><a href="#sec-geom-waterfall-1-1-1-compute-panel-geomrect"><span class="section-number">4.5</span> geom_waterfall: <strong>1:1:1, compute_panel, GeomRect</strong></a>
<ul>
<li><a href="#sec-step-0-use-base-ggplot2_4"><span class="section-number">4.5.1</span> Step 0. Use base ggplot2</a></li>
<li><a href="#sec-steps-1-compute"><span class="section-number">4.5.2</span> Steps 1. compute</a></li>
<li><a href="#sec-step-2-define-stat-passing-to-ggproto"><span class="section-number">4.5.3</span> Step 2. Define Stat, passing to ggproto</a></li>
<li><a href="#sec-step-3-pass-to-user-facing-function_1"><span class="section-number">4.5.4</span> Step 3. Pass to user-facing function</a></li>
<li><a href="#sec-step-4-use-test-enjoy_4"><span class="section-number">4.5.5</span> Step 4. Use/test/enjoy</a></li>
<li><a href="#sec-bonus-default-aes-using-delayed-aesthetic-evaluation-d-a-e"><span class="section-number">4.5.6</span> Bonus: default <code>aes</code> using delayed aesthetic evaluation (D.A.E.)</a></li>
</ul>
</li>
<li><a href="#sec-geom-circlepack-1-1-n-compute-panel-geompolygon"><span class="section-number">4.6</span> geom_circlepack: <strong>1:1:n, compute_panel, GeomPolygon</strong></a>
<ul>
<li><a href="#sec-step-0-how-to-w-base-ggplot2-and-packcircles"><span class="section-number">4.6.1</span> Step 0. How-to w/ base ggplot2 (and {packcircles})</a></li>
<li><a href="#sec-step-1-compute_4"><span class="section-number">4.6.2</span> Step 1. Compute</a></li>
<li><a href="#sec-step-2-pass-to-ggproto-object_2"><span class="section-number">4.6.3</span> Step 2. pass to ggproto object</a></li>
<li><a href="#sec-step-3-pass-to-user-facing-function_2"><span class="section-number">4.6.4</span> Step 3. pass to user-facing function</a></li>
<li><a href="#sec-step-4-use-test-enjoy_5"><span class="section-number">4.6.5</span> Step 4. Use/test/enjoy</a></li>
</ul>
</li>
<li><a href="#sec-geom-circle-1-1-n-compute-panel-geompolygon"><span class="section-number">4.7</span> geom_circle: <strong>1:1:n, compute_panel, GeomPolygon</strong></a>
<ul>
<li><a href="#sec-step-0-do-it-with-base-ggplot2"><span class="section-number">4.7.1</span> Step 0. Do it with base ggplot2</a></li>
<li><a href="#sec-step-1-compute_5"><span class="section-number">4.7.2</span> Step 1. Compute</a></li>
<li><a href="#sec-step-2-pass-to-ggproto_3"><span class="section-number">4.7.3</span> Step 2. Pass to ggproto</a></li>
<li><a href="#sec-step-3-write-geom-or-stat"><span class="section-number">4.7.4</span> Step 3. Write geom_* or stat_*</a></li>
<li><a href="#sec-step-4-enjoy-test"><span class="section-number">4.7.5</span> Step 4: Enjoy (test)</a></li>
<li><a href="#sec-discussion-why-not-compute-group"><span class="section-number">4.7.6</span> Discussion: Why not compute_group</a></li>
<li><a href="#sec-exercise-write-the-function-geom-heart-that-will-take-the-compute-below-and-do-it-within-the-geom-function"><span class="section-number">4.7.7</span> Exercise: Write the function, geom_heart() that will take the compute below and do it within the geom_* function</a></li>
</ul>
</li>
<li><a href="#sec-geom-state-1-1-n-compute-panel-geompolygon"><span class="section-number">4.8</span> geom_state: <strong>1:1:n, compute_panel, GeomPolygon</strong></a>
<ul>
<li><a href="#sec-step-0-use-base-ggplot2_5"><span class="section-number">4.8.1</span> Step 0:  use base ggplot2</a></li>
<li><a href="#sec-step-1-write-compute-function_2"><span class="section-number">4.8.2</span> Step 1:  Write compute function üöß</a></li>
<li><a href="#sec-step-2-pass-to-ggproto_4"><span class="section-number">4.8.3</span> Step 2. Pass to ggproto</a></li>
<li><a href="#sec-step-3-pass-to-user-facing-function_3"><span class="section-number">4.8.4</span> Step 3. Pass to user-facing function</a></li>
<li><a href="#sec-step-4-use-test-enjoy_6"><span class="section-number">4.8.5</span> Step 4. Use/Test/Enjoy</a></li>
</ul>
</li>
<li><a href="#sec-geom-ols-linear-parallel-n-k-w-interdependence"><span class="section-number">4.9</span> geom_ols_linear_parallel: <strong>n:k:w; interdependence</strong></a>
<ul>
<li><a href="#sec-step-1-get-the-job-done-with-ggplot2"><span class="section-number">4.9.1</span> Step 1. Get the job done with ggplot2</a></li>
<li><a href="#sec-step-2-pass-compute-to-ggproto-object"><span class="section-number">4.9.2</span> Step 2. Pass compute to ggproto object</a></li>
<li><a href="#sec-step-3-pass-to-user-facing-function_4"><span class="section-number">4.9.3</span> Step 3. Pass to user-facing function</a></li>
<li><a href="#sec-step-4-use-test-enjoy_7"><span class="section-number">4.9.4</span> Step 4. Use/test/enjoy</a></li>
</ul>
</li>
<li><a href="#sec-geom-county-1-1-1-compute-panel-geomsf"><span class="section-number">4.10</span> geom_county: <em><em>1:1:1</em>, compute_panel, GeomSf</em>*</a>
<ul>
<li><a href="#sec-step-0-get-it-done-in-base-ggplot2"><span class="section-number">4.10.1</span> Step 0. get it done in base ggplot2</a></li>
<li><a href="#sec-step-1-compute_6"><span class="section-number">4.10.2</span> Step 1. compute</a></li>
<li><a href="#sec-step-2-pass-to-ggproto-object_3"><span class="section-number">4.10.3</span> Step 2. pass to ggproto object</a></li>
<li><a href="#sec-step-3-pass-to-user-facing-function-wrapping-ggplot-layer-sf-instead-of-ggplot2-layer-more-check-with-crss"><span class="section-number">4.10.4</span> Step 3. pass to user-facing function (wrapping ggplot::layer_sf() instead of ggplot2::layer())  üöß <em>more check with CRSs</em></a></li>
<li><a href="#sec-step-4-use-test-enjoy_8"><span class="section-number">4.10.5</span> Step 4. Use/test/enjoy!</a></li>
</ul>
</li>
<li><a href="#sec-geom-county-label-1-1-1-geomtext"><span class="section-number">4.11</span> geom_county_label: **1:1:1; GeomText **</a>
<ul>
<li><a href="#sec-step-1-compute_7"><span class="section-number">4.11.1</span> Step 1 compute</a></li>
<li><a href="#sec-step-2_1"><span class="section-number">4.11.2</span> Step 2</a></li>
<li><a href="#sec-step-3_1"><span class="section-number">4.11.3</span> Step 3</a></li>
<li><a href="#sec-step-4"><span class="section-number">4.11.4</span> Step 4</a></li>
<li><a href="#sec-exercise_1"><span class="section-number">4.11.5</span> Exercise</a></li>
<li><a href="#sec-exercise_2"><span class="section-number">4.11.6</span> Exercise</a></li>
</ul>
</li>
<li><a href="#sec-geom-candlestick-summarize-first-then-interdependence"><span class="section-number">4.12</span> geom_candlestick summarize first, then interdependence ‚Ä¶</a></li>
</ul>
</li>
<li><a href="#sec-stat-layers-keeping-flexible-via-stat-functions"><span class="section-number main-number">5</span> stat_* layers: keeping flexible via stat_* functions</a>
<ul>
<li><a href="#sec-stat-chull-n-1-n-compute-group-geompolygon-geomtext-geompoint"><span class="section-number">5.1</span> stat_chull: <strong>N:1:n; compute_group; GeomPolygon, GeomText, GeomPoint</strong></a></li>
<li><a href="#sec-stat-waterfall-1-1-1-compute-panel-geomrect-geomtext"><span class="section-number">5.2</span> stat_waterfall: <strong>1:1:1; compute_panel; GeomRect, GeomText</strong></a></li>
<li><a href="#sec-bonus-part-2-dae-with-geomtext-target"><span class="section-number">5.3</span> Bonus part 2. DAE with GeomText target</a></li>
</ul>
</li>
<li><a href="#sec-piggyback-on-compute"><span class="section-number main-number">6</span> Piggyback on compute</a>
<ul>
<li><a href="#sec-some-delayed-aesthetic-evaluation"><span class="section-number">6.1</span> Some Delayed Aesthetic Evaluation</a></li>
<li><a href="#sec-borrowing-compute"><span class="section-number">6.2</span> Borrowing compute</a></li>
<li><a href="#sec-geom-smoothfit-1-1-1-ggproto-piggybacking-on-compute"><span class="section-number">6.3</span> geom_smoothfit: <strong>1:1:1</strong> ggproto piggybacking on compute‚Ä¶</a>
<ul>
<li><a href="#sec-step-1-compute_8"><span class="section-number">6.3.1</span> Step 1. compute</a></li>
<li><a href="#sec-step-2_2"><span class="section-number">6.3.2</span> Step 2</a></li>
<li><a href="#sec-step-3_2"><span class="section-number">6.3.3</span> Step 3</a></li>
</ul>
</li>
<li><a href="#sec-add-default-aesthetics"><span class="section-number">6.4</span> add default aesthetics</a></li>
<li><a href="#sec-geom-barlab-adding-defaults-to-existing-stats-via-ggproto-editing"><span class="section-number">6.5</span> geom_barlab:  Adding defaults to existing stats via ggproto editing</a></li>
</ul>
</li>
<li><a href="#sec-facet-sample"><span class="section-number main-number">7</span> facet_sample</a></li>
<li><a href="#sec-theme-chalkboard"><span class="section-number main-number">8</span> theme_chalkboard()</a></li>
<li><a href="#sec-coords"><span class="section-number main-number">9</span> Coords</a>
<ul>
<li><a href="#sec-coord-page"><span class="section-number">9.1</span> coord_page()</a></li>
</ul>
</li>
<li><a href="#sec-coord-poster"><span class="section-number main-number">10</span> coord_poster()</a></li>
<li><a href="#sec-modified-start-points-ggverbatim"><span class="section-number main-number">11</span> modified start points; ggverbatim(),</a>
<ul>
<li><a href="#sec-ggverbatim"><span class="section-number">11.1</span> ggverbatim()</a></li>
</ul>
</li>
<li><a href="#sec-ggedgelist"><span class="section-number main-number">12</span> ggedgelist()</a>
<ul>
<li><a href="#sec-ggscatterplot-rearrangement"><span class="section-number">12.1</span> ggscatterplot(), rearrangement</a></li>
</ul>
</li>
<li><a href="#sec-wrapping-fiddly-functions-annotate-and-theme"><span class="section-number main-number">13</span> wrapping fiddly functions (annotate and theme)</a></li>
<li><a href="#sec-make-it-a-package-ggtedious-formal-testing"><span class="section-number main-number">14</span> make it a package:  ggtedious <em>formal testing</em></a></li>
</ul>
</div>
<div class="chapter body" data-source="../ggplot2-extension-cookbook/README.Rmd">
<div class="chapter-before side side-right">
</div>
<!-- README.md is generated from README.Rmd. Please edit that file -->
<h1 id="sec-ggplot2-extension-cookbook"><span class="section-number main-number">1</span> ggplot2-extension-cookbook</h1>
<!-- badges: start -->
<!-- badges: end -->
<p>This <em>ggplot2 Extension Cookbook</em> aims to provide ggplot2 some extension strategies in a consistent and accessible way.  The target audience is fluent ggplot2 and R users who have not yet entered the extension space.  The main tactic is to provide many extensions examples for building familiarity and confidence, and also which might serve as specific reference when readers are inspired to build their own extensions.</p>
<p>In that material, I‚Äôll try to stick to an enumerated formula to orient you to the ggplot2 extension, so even if a few details seem confusing, you‚Äôll know ‚Äòwhere‚Äô you are at a higher level:</p>
<ul>
<li>Step 0: get job done with ‚Äòbase‚Äô ggplot2</li>
<li>Step 1: Write a function for the ‚Äòcompute‚Äô</li>
<li>Step 2: Pass the compute to ggproto object</li>
<li>Step 3: Pass ggproto to a user-facing function for use in a ggplot() pipeline</li>
<li>Step 4: Try out/test/enjoy!</li>
</ul>
<p>We group the content by extension type, provide demonstrations of their use.   Right now, there is a lot of focuses on new geom_* and stat_* layer functions. I think this is an important area to illuminate because many of these allow us to pass off routine computational task to the plotting system.  This importance translates to excitement about ggplot2 extension packages: new geom_* layers functions really rule the day when it comes to outside interest.  See for example <a href="https://albert-rapp.de/posts/ggplot2-tips/20_ggplot_extensions/ggplot_extensions">‚Äò5 powerful ggplot2 extensions‚Äô, Rapp 2024</a> in which four of the five focus on new geoms that are made available by packages and <a href="https://www.cedricscherer.com/slides/RLadiesTunis-2021-favorite-ggplot-extensions.pdf">‚ÄòFavorite ggplot2 extensions‚Äô, Scherer 2021</a> in which almost all of the highlighted extensions are geom_* and stat_* user-facing functions.</p>
<p>Regarding focus on stat_‚Äôs <em>versus</em> geom_‚Äòs functions, I take a geom_* -first approach, because these functions are more commonly used in layman‚Äôs ggplot builds.  I suspect we find geom_* functions to be more concrete descriptions of what the creator envisions for her plot, whereas stat_* function names may feel a be more ‚Äòadverbial‚Äô and nebulous in their description of rendered output. Consider that ggplot(mtcars, aes(wt, mpg)) + stat_identity() and ggplot(mtcars, aes(wt, mpg)) + geom_point() create identical plots, but later seems much more descriptive of the resultant plot. Between these two particular options, the preference for the geom_point is evident in the user data; on Github, there are 788 R language files containing ‚Äòstat_identity‚Äô whereas a staggering 261-thousand R language files contain ‚Äògeom_point‚Äô.  Of course, stat_* constructions are quite flexible and expressive, and more seasoned ggplot2 users use them with great fluency, and therefore the topic is covered.</p>
<p>Finally, most of the code is at the ‚ÄòR for Data Science‚Äô level, and not ‚ÄòAdvanced R‚Äô level, which I hope will afford greater reach.  While object oriented programming (OOP) gets top billing in many extension materials, but many folks that <em>are</em> expert users of ggplot2 might <em>not</em> know much about OOP.  I see what can be accomplished with little emphasis on OOP and ggroto.</p>
<p>Reader, I do think it is important for you to recognize that ggplot2 objects (i.e. p in p &lt;- ggplot(cars, aes(speed, dist)) + geom_point()) are not, of course the rendered plot, but rather a plot specification (of global data, aesthetic mapping, etc) that result from the declarations the user has made.  But I think you‚Äôve probably made this realization very early on in your ggplot2 journey already.  You know that the ggplot plot building syntax allows users to make changes to the overall plot <em>specification</em> incrementally. In other words the <code>+</code> operator allows us to modify the the ggplot2 object. And the ggroto system allows changes to the ggplot2 specification from outside the ggplot2 package too ‚Äî from extension packages.</p>
<p>For those who have dipped your toes into extension, the composition of the extension elements will look different from what you will see in the wild.  Specifically, I try to define ggproto objects in as concise and high-level a way as possible ‚Äî and as close to <em>ignorable</em> for those put off or nervous about OOP methods.</p>
<p>For example defining the object StatCoordinate looks like this:</p>
<pre><code class="language-r">StatCoordinate &lt;- ggplot2::ggproto(
  `_class` = &quot;StatCoordinate&quot;,
  `_inherit` = ggplot2::Stat,
  required_aes = c(&quot;x&quot;, &quot;y&quot;),
  compute_group = compute_group_coordinates
  )
</code></pre>
<p>Currently, with the geom_* and stat_* layers, I‚Äôm experimenting with a ratio typology that you‚Äôll see in the section titles. The idea is to think about how the input data relates to the mark we see on the plot and in turn how the mark‚Äôs information is stored in the ggplot2 object. This is a brand new undertaking, and I‚Äôm unsure of how productive or precise it will be.</p>
<p>Overall, I think the resources in this ggplot2 extension cookbook are aligned with the findings in <a href="https://cacm.acm.org/magazines/2024/1/278891-10-things-software-developers-should-learn-about-learning/fulltext">‚Äò10 Things Software Developers Should Learn about Learning‚Äô</a>, especially the observation that new techniques and ideas are often best internalized when first applied to concrete examples; general principles may be more grounded if situated in relevant examples.</p>
<h1 id="sec-preface-and-acknowledgements"><span class="section-number main-number">2</span> Preface and acknowledgements</h1>
<p>In January 2020, I attended Thomas Lin Pederson‚Äôs talk ‚ÄòExtending your ability to extend ggplot2‚Äô seated on the floor of a packed out ballroom.  The talk had the important central message - ‚Äúyou can be a ggplot2 extender‚Äù.  And since then, I wanted to be in that cool-kid extender club.  Four years later, I‚Äôm at a point where I can start claiming that club membership.   I hope that this <em>ggplot2 Extension Cookbook</em> will help along you on your extender journey and, especially if you are fluent in R and ggplot2, it says to you ‚Äúyou can be a ggplot2 extender‚Äù.</p>
<p>I became a regular ggplot2 user in 2017.  I loved how, in general, the syntax was just a simple expression of the core Grammar of Graphics conception of a ‚Äòstatistical graphic‚Äô (i.e. data visualization).</p>
<blockquote>
<p>A data visualization displays</p>
</blockquote>
<ol>
<li>geometric mark</li>
<li>that take on aesthetics (color, size, position, etc) that represent variables</li>
<li>from a dataset.</li>
</ol>
<p>You can learn so much about data via a simple 3-2-1 ‚Äî data-mapping-mark ‚Äî ggplot2 utterance. And further modifications could be made bit-by-bit, too, to completely tailor the plot to the creator‚Äôs visual personal preferences.</p>
<p>All of this closely resembles to how you might sketch out a plot on a notepad or blackboard, or describe your data representation decisions to yourself or a colleague.  As Thomas Lin Pederson has said, ‚Äòggplot2 lets you <em>speak your plot into existence</em>‚Äô.  And perhaps a little less eloquently by Hadley Wickham‚Äôs, the ggplot2 author,  ‚ÄúThis is what I‚Äôm thinking; your the computer, now go and do it!‚Äù, a paraphrase of the author talking about how he thought data viz <em>should</em> feel as a graduate student statistical consultant ‚Äì before ggplot2 existed.</p>
<p>But there were admittedly pain points when using ‚Äòbase‚Äô ggplot2; for me, this was mostly when a geom_* function didn‚Äôt exist for doing some compute in the background, and I would need such compute done over and over.  It would be a slough to work on the compute for a bunch of subsets of the data upstream to the plotting environment. This pre-computation problem felt manageable in an academic and classroom setting that I found myself in through early in my data career but when I moved to a primarily analytic role (West Point, Fall 2020) ‚Äî where the volume of analysis was simply higher and turn around times faster ‚Äî I felt the problem much more acutely.  (Overnight, I went from weak preference for geom_col - to strong preference for geom_bar!)   Extension seemed to offer the solution to the problem, and I was more motivated than ever to figure extension out in my analyst role.</p>
<p>I experienced about a year of failure and frustration when first entering the extension space.  If I weren‚Äôt so convinced of the efficiency gains that it would eventually yield and the elegance of extension, I‚Äôd likely have given up.  Looking back and recognizing the substantial hurdles for even long time R and ggplot2 users, as I was, I think there is space for more ggplot2 extension reference materials like this <em>ggplot2 Extension Cookbook</em>.</p>
<p>I‚Äôm grateful for several experiences and the efforts of others that have refined my thinking about what will work for newcomers to extension  First, after just getting my own feet wet in extension, I had the chance to work on extension with underclassmen, undergraduate students in the context of their independent studies.  Our focus was the same type of extension that Pederson demonstrated ‚Äì a geom_* function that used a Stat to do some computational work, and then inherit the rest of its behavior from a more primitive geom.</p>
<p>Working with new-to-R students gave me a chance to reflect on my fledgling workflow and reformulate it; how would we build up skills and ideas in way that would be accessible to <em>very</em> new R and ggplot2 users. What would these students ‚Äì veterans of just one or two stats classes that used R and ggplot2, find familiar and accessible?  What might we be able to de-emphasize? ggproto and object oriented programming hadn‚Äôt been touched in coursework.  Could we still still succeed with extension?</p>
<p>The following steps emerged:</p>
<ul>
<li>Step 0: get job done with ‚Äòbase‚Äô ggplot2</li>
<li>Step 1: Write a function for the ‚Äòcompute‚Äô</li>
<li>Step 2: Pass the compute to ggproto</li>
<li>Step 3: Pass ggproto to stat/geom/facet function</li>
<li>Step 4: Try out/test/enjoy!</li>
</ul>
<p>Taking new R users into the extension space was a leap of faith.  But I was very impressed with what the students were able to accomplish during a single semester.</p>
<p>And I also wondered how the strategy would perform with experienced R and ggplot2 users.  Curious, I created a tutorial [with assistance from independent study student Morgan Brown, who continued to work with me for a second semester] called ‚ÄòEasy-Geom-Recipes‚Äô formally got feedback on it via focus groups and a survey, after refining the tutorial, with a small group of stats educator which we might term ggplot and R super users given their frequency and length of use of these materials.</p>
<p>Among my favorite quotation from the focus groups is something that validated the efforts but also challenged me:</p>
<blockquote>
<p>it was ‚Ä¶ easy. And I felt empowered as a result of that‚Ä¶. But you know, like, my problem isn‚Äôt gonna be that easy.</p>
</blockquote>
<p>To that participant, I‚Äôd say ‚ÄòSometimes it <em>is</em> that easy‚Äô.  But he is right, that often times I come to an extension problem and am surprised that the strategy that I think is going to work doesn‚Äôt, or at least not without a little fiddling.</p>
<p>The <a href="https://github.com/EvaMaeRey/easy-geom-recipes">feedback on the easy-geom-recipes</a> was collected in March 2023.  I presented on the outcomes at the ASA Chapter meeting of COWY, <a href="https://evamaerey.github.io/mytidytuesday/2023-09-26-cowy-outline/cowy-slides.html#1">‚ÄòA New Wave of ggplot2 Extenders‚Äô</a>.</p>
<p>After presenting on the success of ‚Äòeasy geom recipes‚Äô, I felt I was at a crossroads.  I could either focus on packaging my material as educational, or I could actually write extensions in R packages.  The later felt a little more true to my interests, but I felt torn.   Happily, I ended up landing a solution where I could have it <em>both ways</em>: writing packages that preserve the story and create recipes along the way.   This was enabled by a literate programming mindset generally, and specifically thinly wrapping knitr::knitr_code$get() in my own helper package {readme2pkg}; the functions in {readme2pkg} send code chunks to the appropriate directories for packaging, but live in the README.Rmd as part of the development narrative. (see to {litr} as an alternative to {readme2pkg}).  I‚Äôm returning to to squarely focus on education in creating this <em>ggplot2 extension cookbook</em>.  It has been very easy to pull in material from those packages given their adherence a specific narrative form.  In mocking up this book, I‚Äôm using code chunk options like <code>child = '../my_gg_experiments/my_extension_ideas.'</code> and <code>code = '../ggwaterfall/R/geom_waterfall'.</code>  It is a great help not to have to pull up files and copy and paste.  I‚Äôm very grateful to Yihui Xie for his insights and efforts at making this possible.</p>
<p>I‚Äôm personally grateful to other ggplot2 extenders and R enthusiasts that have supported this journey.</p>
<p>I‚Äôm also grateful to the ggplot2 development team .</p>
<p>I‚Äôm also indebted to my Department of Mathematics and Dean Data Cell colleagues at West Point, for sitting through some talks (some extemporaneous and muddled) where I tried to articulate my ggplot2 extension dreams.</p>
<p>Finally, to Winston Chang, who gets top billing in the ggplot2 extension vignette along with your ggproto, I hope you won‚Äôt mind the general approach here which experiments with making ggproto as ignorable as possible for OOP noobs.  I also hope to meet you someday and hear more about the early days of ggproto, maybe at ggplot2 extenders meetup as a special guest, perhaps January 2025.</p>
<p>And finally, finally to Hadley Wickham and Leland Wilkinson having incredible insights and acting on them.</p>
<h1 id="sec-getting-started"><span class="section-number main-number">3</span> Getting started</h1>
<p>For best results, I‚Äôd recommend <em>diving</em> in by actually creating some geoms as prompted in the ‚Äòeasy geom recipes‚Äô tutorial using the rendered <a href="https://evamaerey.github.io/easy-geom-recipes/easy_geom_recipes_compute_group.html">tutorial</a> or <a href="https://raw.githubusercontent.com/EvaMaeRey/easy-geom-recipes/main/easy_geom_recipes_compute_group.Rmd">text .Rmd file</a>. The ‚Äòeasy recipes‚Äô contain 3 fully worked examples, and 3 exercises that extend the lessons in the examples.</p>
<p>Having completed these exercises, you‚Äôll have lived geom creations from start to finish, will be well oriented to the consistent patterns I use, to the extent possible, throughout the cookbook.</p>
<p><img src="README__files/chunk-5-1.png" alt="" /></p>
<h1 id="sec-easy-geom-functions-writing-new-definitions-for-where-and-how-of-marks-on-ggplots"><span class="section-number main-number">4</span> easy geom_* functions: writing new definitions for where and how of marks on ggplots</h1>
<p>This section tackles creating new geom_* layers.  The strategy is to look at compute that you‚Äôd do without extension capabilities (Step 0), and then create a Stat for that (Step 1 &amp; 2), and then compose a user-facing function, which inherits other behavior from a more primitive geom (Step 3), so that ggplot2 can do compute for you in the background (Step 4).</p>
<p>The section is called <em>easy</em> geoms because these geom functions actually inherit much behavior from more primitive geoms like col, text, point, segment, rect, etc..</p>
<h2 id="sec-geom-text-coordinate-1-1-1-compute-group-geomtext"><span class="section-number">4.1</span> geom_text_coordinate: <strong>1:1:1, compute_group, GeomText</strong></h2>
<p>The proposed function geom_text_coordinate() is one where a label for an x and y position is automatically computed.  The target user interface will only require x and y to be specified as aesthetics, and will look something like this.  Whereas the geom_text() function would require a label aesthetic, geom_text_coordinate will compute this label variable within the function call.</p>
<pre><code class="language-r">ggplot(data = cars) + 
  aes(x = speed, y = dist) + 
  geom_point() + 
  geom_text_coordinate()
</code></pre>
<p>We‚Äôll be computing a ‚Äò1:1:1‚Äô type layer, which means that for each row of the input dataframe, a single mark will be drawn, and the internal data frame that ggplot2 will render with will use a single row per mark.</p>
<h3 id="sec-step-0-use-base-ggplot2_1"><span class="section-number">4.1.1</span> Step 0: use base ggplot2</h3>
<p>We‚Äôll always start with a ‚Äòstep 0‚Äô.  The groundwork and knowledge that I assume you have is to build this plot without extending ggplot2. The computation that you do yourself will serve as useful reference for step 1 of the extension process.  Ultimately, we would like a ggplot2 function to do the compute in the background for us.</p>
<pre><code class="language-r">library(tidyverse)
library(ggxmean)

cars |&gt;
  mutate(coords = 
           paste0(&quot;(&quot;, speed, &quot;,&quot;, dist, &quot;)&quot;)) |&gt;
  ggplot() + 
  aes(x = speed, y = dist) + 
  geom_point() + 
  geom_text(aes(label = coords), 
            check_overlap = T,
            hjust = 0,
            vjust = 0)
</code></pre>
<p><img src="README__files/chunk-9-1.png" alt="" /></p>
<h3 id="sec-step-1-compute_1"><span class="section-number">4.1.2</span> Step 1: Compute</h3>
<p>Next, we turn to writing this compute in a way that ggplot2 layer functions can use.</p>
<p>Compute functions will capture the compute that our a user-facing function will ultimately do for us in a plot build. Arguments that are required for ggplot2 to use the function in its preparation are both <code>data</code> and <code>scales</code>.  For now, we don‚Äôt need worry more about the scales argument.</p>
<p>The data that serves as input can be assumed to contain columns with certain variable names ‚Äî the required aesthetics that we‚Äôll see declared in the next step. For the function that we‚Äôre building, the required aesthetics will be ‚Äòx‚Äô and ‚Äòy‚Äô.  In the <code>compute_group_coordinates()</code> function, therefore, the mutate step is possible because the data will have variables named x and y.  In the mutate step, we are creating a variable that ggplot2 understands internally, <code>label</code>.</p>
<pre><code class="language-r">compute_group_coordinates &lt;- function(data, scales) {

# data will contain variables 'x' and 'y', because of required aes
data |&gt;                                    
    mutate(label = 
             paste0(&quot;(&quot;, x, &quot;, &quot;, y, &quot;)&quot;))
}
</code></pre>
<p>Before we move on, it‚Äôs a good idea to check out that our function is working on its own.  To use the function, remember that we need a dataframe with the expected variables, <code>x</code> and <code>y</code>.  We can test the function with the cars dataset, but first we modify the data (that has variable names <code>speed</code> and <code>dist</code>) with the rename function.</p>
<pre><code class="language-r">cars |&gt; 
  rename(x = speed, y = dist) |&gt;  # rename allows us to test function
  compute_group_coordinates() |&gt; 
  head()
</code></pre>
<table>
<thead>
<tr>
<th align="right">x</th>
<th align="right">y</th>
<th>label</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">4</td>
<td align="right">2</td>
<td>(4, 2)</td>
</tr>
<tr>
<td align="right">4</td>
<td align="right">10</td>
<td>(4, 10)</td>
</tr>
<tr>
<td align="right">7</td>
<td align="right">4</td>
<td>(7, 4)</td>
</tr>
<tr>
<td align="right">7</td>
<td align="right">22</td>
<td>(7, 22)</td>
</tr>
<tr>
<td align="right">8</td>
<td align="right">16</td>
<td>(8, 16)</td>
</tr>
<tr>
<td align="right">9</td>
<td align="right">10</td>
<td>(9, 10)</td>
</tr>
</tbody>
</table>
<h3 id="sec-step-2-pass-to-ggproto-object_1"><span class="section-number">4.1.3</span> Step 2: pass to ggproto object</h3>
<p>The next step toward our user-facing function is to create a new Stat, which is a ggproto object.  Fortunately, this is a subclass of the ggplot2::Stat Class, and we will inherit much behavior from that class.  This means that definition of our class <code>StatCoordinate</code>, is quite straightforward.  For our target function, beyond creating the new class and declaring the inheritance, we‚Äôll need to 1) specify the required aesthetics and 2) pass our compute function to a compute slot.  The slot we‚Äôre using for our coordinates case is compute_group.  Therefore, the compute will be done by group if any discrete variable (non-numeric) is mapped from the data.  The consequences of using the compute_group slot (verse other slots) will become more important in future examples.  Returning to the topic of required_aes, the coordinates label can always be created from x and y as an input, and we know that our compute function uses both variables named ‚Äòx‚Äô and ‚Äòy‚Äô in it‚Äôs computation.</p>
<pre><code class="language-r">StatCoordinate &lt;- ggplot2::ggproto(
  `_class` = &quot;StatCoordinate&quot;,
  `_inherit` = ggplot2::Stat,
  required_aes = c(&quot;x&quot;, &quot;y&quot;),
  compute_group = compute_group_coordinates
  )
</code></pre>
<h3 id="sec-step-3-write-user-facing-function_1"><span class="section-number">4.1.4</span> Step 3. Write user facing function.</h3>
<p>In Step 3, we‚Äôre close to our goal of a user-facing function for familiar ggplot2 builds.</p>
<p>Under the hood, we‚Äôll pass our new Stat, StatCoordinate, to ggplot2‚Äôs <code>layer()</code> function.  <code>ggplot2::layer()</code> is may not be familiar, but it can be used directly in ggplot() pipelines.  We pass our StatCoordinate ggproto object to the stat argument, handling the computation (adding a column of data containing coordinates and called ‚Äòlabel‚Äô).  Additionally the ggplot2::GeomText object to the geom argument.  The ‚Äògeometry‚Äô or ‚Äòmark‚Äô on the plot therefore will be of the ‚Äòtext‚Äô type.</p>
<pre><code class="language-r"># part 3.0 use ggplot2::layer which requires specifying Geom and Stat
ggplot(data = cars) + 
  aes(x = speed, y = dist) + 
  geom_point() + 
  ggplot2::layer(
    stat = StatCoordinate,
    geom = ggplot2::GeomText,
    position = &quot;identity&quot;
    )
</code></pre>
<p><img src="README__files/chunk-13-1.png" alt="" /></p>
<p>You are probably more familiar with <code>geom_*()</code> and <code>stat_*</code> functions which wrap the ggplot2::layer() function; these generally have a fixed geom or stat.  In create <code>geom_text_coordinate()</code>, because the use-scope is so narrow, both the stat and geom are ‚Äòhard-coded‚Äô in the layer; i.e. stat and geom are not arguments in the geom_* function.  Here‚Äôs how we specify our <code>geom_text_coordinate()</code>:</p>
<pre><code class="language-r"># part b. create geom_* user-facing function using g
geom_text_coordinate &lt;- function(mapping = NULL, 
                                 data = NULL,
                                 position = &quot;identity&quot;,
                                 show.legend = NA,
                                 inherit.aes = TRUE, 
                                 na.rm = FALSE,
                                 ...) {
  ggplot2::layer(
    stat = StatCoordinate,
    geom = ggplot2::GeomText, 
    position = position,
    mapping = mapping,
    data = data,
    inherit.aes = inherit.aes,
    show.legend = show.legend,
    params = list(na.rm = na.rm, ...)
  )
}
</code></pre>
<p>You will see a few more arguments in play here: <code>mapping</code>, <code>data</code>, <code>position</code>, <code>show.legend</code>, etc..  We do anticipate that the user might want to have control over the data and aesthetic mapping specific to layer (rather than deriving them from global declarations), and therefore make the mapping and data arguments available.  Furthermore, the position, show.legend, inherit.aes, and na.rm arguments are made available in the geom as shown below.  The ellipsis allows you to leverage even more functionality.  In sum, this makes <code>geom_text_coordinate()</code> work very much like <code>geom_text()</code> ‚Äî you can use all the same arguments you‚Äôd use with geom_text() ‚Äî except that the label aesthetic is computed under the hood, and vanilla <code>geom_text()</code> requires you to specify the label aesthetic.  For example, you can use the argument <code>check_overlap</code> in <code>geom_text_coordinate()</code>, as you might do in <code>geom_text()</code>.</p>
<h3 id="sec-step-4-use-test-enjoy_1"><span class="section-number">4.1.5</span> Step 4: Use/test/enjoy</h3>
<p>Good news, we‚Äôr at Step 4! You created a function for use in a ggplot2 pipeline and now you can use it!  Remember, you can basically use geom_text_coordinate in the same was as geom_text, because the geom argument in the layer() function is geom = GeomText, so arguments like check_overlap that are usable in geom_text will be meaningful our new function! The difference, of course, is that the label aesthetic is computed for you ‚Äì so you don‚Äôt need that aesthetic which would be required for the vanilla geom_text() function.</p>
<pre><code class="language-r">ggplot(data = cars) + 
  aes(x = speed, y = dist) + 
  geom_point() + 
  geom_text_coordinate()
</code></pre>
<p><img src="README__files/chunk-15-1.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(color = speed &gt; 15)
</code></pre>
<p><img src="README__files/chunk-15-2.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  geom_text_coordinate(check_overlap = T,
                       color = &quot;black&quot;)
</code></pre>
<p><img src="README__files/chunk-15-3.png" alt="" /></p>
<pre><code class="language-r">
</code></pre>
<h2 id="sec-geom-post-1-1-1-compute-group-geomsegment"><span class="section-number">4.2</span> geom_post: <strong>1:1:1, compute_group, GeomSegment</strong></h2>
<p>The next proposed function we‚Äôll take on is geom_post().  We can use this function where we are interested in the magnitude of y, not just relative positions of y.  Given that we are interested in the magnitude of y we‚Äôd like a geom that extends from the value of y to y equal to zero, i.e. a ‚Äòpost‚Äô geom.  You can use a geom_segment for this purpose in base ggplot2 as seen in Step 0.  However, you‚Äôll notice that the xend and yend, which are aesthetics that geom_segment requires, could automatically be derived given the requirements of drawing a post.  Therefore, to simplify your future plot compositions, you may want to define an extension function, geom_post().</p>
<h3 id="sec-step-0-use-base-ggplot2_2"><span class="section-number">4.2.1</span> Step 0. Use base ggplot2</h3>
<pre><code class="language-r">probs_df = data.frame(outcome = 0:1, 
       prob = c(.7, .3))

probs_df
</code></pre>
<table>
<thead>
<tr>
<th align="right">outcome</th>
<th align="right">prob</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0</td>
<td align="right">0.7</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">0.3</td>
</tr>
</tbody>
</table>
<pre><code class="language-r">ggplot(data = probs_df) + 
  aes(x = outcome, y = prob, yend = 0, xend = outcome) + 
  geom_point() +
  geom_segment()
</code></pre>
<p><img src="README__files/chunk-16-1.png" alt="" /></p>
<pre><code class="language-r">
</code></pre>
<h3 id="sec-step-1-compute_2"><span class="section-number">4.2.2</span> Step 1:  Compute</h3>
<pre><code class="language-r">compute_group_post &lt;- function(data, scales){
  
  data |&gt;
    dplyr::mutate(xend = x) |&gt;
    dplyr::mutate(yend = 0)
  
}
</code></pre>
<pre><code class="language-r">probs_df |&gt;
  rename(x = outcome, y = prob) |&gt;
  compute_group_post()
</code></pre>
<table>
<thead>
<tr>
<th align="right">x</th>
<th align="right">y</th>
<th align="right">xend</th>
<th align="right">yend</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0</td>
<td align="right">0.7</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">0.3</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<h3 id="sec-step-2-pass-to-ggproto_1"><span class="section-number">4.2.3</span> Step 2: Pass to ggproto</h3>
<pre><code class="language-r">StatPost &lt;- ggplot2::ggproto(&quot;StatPost&quot;,
                               ggplot2::Stat,
                               compute_group = compute_group_post,
                               required_aes = c(&quot;x&quot;, &quot;y&quot;)
)
</code></pre>
<h3 id="sec-step-3-pass-to-user-facing-function-using-ggplot2-layer"><span class="section-number">4.2.4</span> Step 3: Pass to user-facing function using ggplot2::layer()</h3>
<pre><code class="language-r">geom_post &lt;- function(mapping = NULL, 
                          data = NULL,
                          position = &quot;identity&quot;, 
                          na.rm = FALSE, 
                          show.legend = NA,
                          inherit.aes = TRUE, ...) {

  ggplot2::layer(
    stat = StatPost, 
    geom = ggplot2::GeomSegment, 
    data = data, 
    mapping = mapping,
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )

}
</code></pre>
<h3 id="sec-step-4-use-test-enjoy_2"><span class="section-number">4.2.5</span> Step 4: use/test/enjoy</h3>
<pre><code class="language-r">ggplot(data = probs_df) + 
  aes(x = outcome, y = prob) + 
  geom_post()
</code></pre>
<p><img src="README__files/chunk-21-1.png" alt="" /></p>
<h3 id="sec-geom-lollipop-tangential-bonus-topic-combining-layers-into-single-geom-function"><span class="section-number">4.2.6</span> geom_lollipop: Tangential bonus topic: Combining layers into single geom_*() function</h3>
<pre><code class="language-r">geom_lollipop &lt;- function(...){
  
  list(geom_post(...),
       geom_point(...))
  
}

ggplot(probs_df) + 
  aes(x = outcome, y = prob) +
  geom_lollipop(color = &quot;magenta&quot;)
</code></pre>
<p><img src="README__files/chunk-22-1.png" alt="" /></p>
<h2 id="sec-geom-xy-means-n-1-1-compute-group-geompoint"><span class="section-number">4.3</span> geom_xy_means: <strong>n:1:1, compute_group, GeomPoint</strong></h2>
<p><em>many rows from a dataset: will be summarized and visualized by as single mark: the mark will be defined by one row of data</em></p>
<h3 id="sec-step-0-use-base-ggplot2_3"><span class="section-number">4.3.1</span> Step 0.  Use base ggplot2</h3>
<pre><code class="language-r">mtcar_xy_means &lt;- mtcars |&gt;
  summarize(wt_mean = mean(wt),
            mpg_mean = mean(mpg))

ggplot(mtcars) + 
  aes(x = wt, y = mpg) + 
  geom_point() + 
  geom_point(data = mtcar_xy_means,
             aes(x = wt_mean, y = mpg_mean),
             size = 8)
</code></pre>
<p><img src="README__files/chunk-23-1.png" alt="" /></p>
<h3 id="sec-step-1-write-compute-function_1"><span class="section-number">4.3.2</span> Step 1. Write compute function</h3>
<pre><code class="language-r">compute_group_means &lt;- function(data, scales){
  
  data |&gt;
    summarise(x = mean(x),
              y = mean(y))
  
}
</code></pre>
<h3 id="sec-step-2-define-stat-pasing-in-compute"><span class="section-number">4.3.3</span> Step 2. Define Stat, pasing in compute</h3>
<pre><code class="language-r">StatXymean &lt;- ggplot2::ggproto(&quot;StatXymean&quot;,
                               ggplot2::Stat,
                               compute_group = compute_group_means,
                               required_aes = c(&quot;x&quot;, &quot;y&quot;)
)
</code></pre>
<h3 id="sec-step-3-write-user-facing-function_2"><span class="section-number">4.3.4</span> Step 3. Write user-facing function</h3>
<pre><code class="language-r">geom_xy_means &lt;- function(mapping = NULL, 
                          data = NULL,
                          position = &quot;identity&quot;, 
                          na.rm = FALSE, 
                          show.legend = NA,
                          inherit.aes = TRUE, ...) {

  ggplot2::layer(
    stat = StatXymean, 
    geom = ggplot2::GeomPoint, 
    data = data, 
    mapping = mapping,
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )

}
</code></pre>
<h3 id="sec-step-4-use-test-enjoy_3"><span class="section-number">4.3.5</span> Step 4. Use/Test/Enjoy</h3>
<pre><code class="language-r">ggplot(mtcars) + 
  aes(x = wt, y = mpg) + 
  geom_point() + 
  geom_xy_means(size = 8)
</code></pre>
<p><img src="README__files/chunk-27-1.png" alt="" /></p>
<pre><code class="language-r">last_plot() +
  aes(color = am == 1)
</code></pre>
<p><img src="README__files/chunk-27-2.png" alt="" /></p>
<pre><code class="language-r">
</code></pre>
<h2 id="sec-geom-chull-n-1-n-compute-group-geompolygon"><span class="section-number">4.4</span> geom_chull: <strong>N:1:n, compute_group, GeomPolygon</strong></h2>
<p>This example uses the chull function in R, which ‚Äòcomputes the subset of points which lie on the convex hull of the set of points specified.‚Äô  In layman‚Äôs terms if you had a bunch of nails hammered into a board and put a rubber-band around them, the convex hull would be defined by the subset of nails touching the rubberband.</p>
<p>I‚Äôm especially excited to include this example, reworked using the Step 0-4 approach, because ultimately looking at the ggplot2 extension vignette on stat_chull and geom_chull was the beginning of layer extension unlocking for me.
<a href="https://ggplot2.tidyverse.org/articles/extending-ggplot2.html#creating-a-new-stat">https://ggplot2.tidyverse.org/articles/extending-ggplot2.html#creating-a-new-stat</a></p>
<h3 id="sec-step-0-get-it-done-with-ggplot2"><span class="section-number">4.4.1</span> Step 0. get it done with ggplot2</h3>
<pre><code class="language-r">library(tidyverse)
chull_row_ids &lt;- chull(mtcars$wt, mtcars$mpg)
chull_row_ids
</code></pre>
<pre><code>#&gt;  [1] 17 16 15 24  7 29 21  3 28 20 18
</code></pre>
<pre><code class="language-r">mtcars_chull_subset &lt;- mtcars |&gt; slice(chull_row_ids)

ggplot(mtcars) + 
  aes(x = wt, y = mpg) + 
  geom_point() + 
  geom_polygon(data = mtcars_chull_subset, 
               alpha = .3, 
               color = &quot;black&quot;)
</code></pre>
<p><img src="README__files/chunk-28-1.png" alt="" /></p>
<h3 id="sec-step-1-compute_3"><span class="section-number">4.4.2</span> Step 1. Compute</h3>
<pre><code class="language-r"># Step 1
compute_group_c_hull &lt;- function(data, scales){
  
  chull_row_ids &lt;- chull(data$x, data$y)
  
  data |&gt; slice(chull_row_ids)
  
}
</code></pre>
<p>Below, we see that the dataset is reduced to 11 rows which constitute the convex hull perimeter.</p>
<pre><code class="language-r">mtcars |&gt; # 32 rows
  rename(x = wt, y = mpg) |&gt; 
  compute_group_c_hull() # 11 rows
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th align="right">y</th>
<th align="right">cyl</th>
<th align="right">disp</th>
<th align="right">hp</th>
<th align="right">drat</th>
<th align="right">x</th>
<th align="right">qsec</th>
<th align="right">vs</th>
<th align="right">am</th>
<th align="right">gear</th>
<th align="right">carb</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrysler Imperial</td>
<td align="right">14.7</td>
<td align="right">8</td>
<td align="right">440.0</td>
<td align="right">230</td>
<td align="right">3.23</td>
<td align="right">5.345</td>
<td align="right">17.42</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">4</td>
</tr>
<tr>
<td>Lincoln Continental</td>
<td align="right">10.4</td>
<td align="right">8</td>
<td align="right">460.0</td>
<td align="right">215</td>
<td align="right">3.00</td>
<td align="right">5.424</td>
<td align="right">17.82</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">4</td>
</tr>
<tr>
<td>Cadillac Fleetwood</td>
<td align="right">10.4</td>
<td align="right">8</td>
<td align="right">472.0</td>
<td align="right">205</td>
<td align="right">2.93</td>
<td align="right">5.250</td>
<td align="right">17.98</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">4</td>
</tr>
<tr>
<td>Camaro Z28</td>
<td align="right">13.3</td>
<td align="right">8</td>
<td align="right">350.0</td>
<td align="right">245</td>
<td align="right">3.73</td>
<td align="right">3.840</td>
<td align="right">15.41</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">4</td>
</tr>
<tr>
<td>Duster 360</td>
<td align="right">14.3</td>
<td align="right">8</td>
<td align="right">360.0</td>
<td align="right">245</td>
<td align="right">3.21</td>
<td align="right">3.570</td>
<td align="right">15.84</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">4</td>
</tr>
<tr>
<td></td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
</tr>
<tr>
<td>Toyota Corona</td>
<td align="right">21.5</td>
<td align="right">4</td>
<td align="right">120.1</td>
<td align="right">97</td>
<td align="right">3.70</td>
<td align="right">2.465</td>
<td align="right">20.01</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
</tr>
<tr>
<td>Datsun 710</td>
<td align="right">22.8</td>
<td align="right">4</td>
<td align="right">108.0</td>
<td align="right">93</td>
<td align="right">3.85</td>
<td align="right">2.320</td>
<td align="right">18.61</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">1</td>
</tr>
<tr>
<td>Lotus Europa</td>
<td align="right">30.4</td>
<td align="right">4</td>
<td align="right">95.1</td>
<td align="right">113</td>
<td align="right">3.77</td>
<td align="right">1.513</td>
<td align="right">16.90</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">2</td>
</tr>
<tr>
<td>Toyota Corolla</td>
<td align="right">33.9</td>
<td align="right">4</td>
<td align="right">71.1</td>
<td align="right">65</td>
<td align="right">4.22</td>
<td align="right">1.835</td>
<td align="right">19.90</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">1</td>
</tr>
<tr>
<td>Fiat 128</td>
<td align="right">32.4</td>
<td align="right">4</td>
<td align="right">78.7</td>
<td align="right">66</td>
<td align="right">4.08</td>
<td align="right">2.200</td>
<td align="right">19.47</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<h3 id="sec-step-2-pass-to-ggproto_2"><span class="section-number">4.4.3</span> Step 2. Pass to ggproto</h3>
<pre><code class="language-r"># Step 2
StatChull &lt;- ggproto(`_class` = &quot;StatChull&quot;,
                     `_inherit` = ggplot2::Stat,
                     compute_group = compute_group_c_hull,
                     required_aes = c(&quot;x&quot;, &quot;y&quot;))
</code></pre>
<h3 id="sec-step-3-write-user-facing-geom-stat-function-s"><span class="section-number">4.4.4</span> Step 3. Write user-facing geom_/stat_ Function(s)</h3>
<pre><code class="language-r">geom_chull &lt;- function(mapping = NULL, 
                        data = NULL,
                        position = &quot;identity&quot;, 
                        na.rm = FALSE, 
                        show.legend = NA,
                        inherit.aes = TRUE, ...) {

  ggplot2::layer(
    stat = StatChull, 
    geom = ggplot2::GeomPolygon, 
    data = data, mapping = mapping,
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )

}
</code></pre>
<h3 id="sec-step-4-try-out-test-enjoy"><span class="section-number">4.4.5</span> Step 4. Try out/test/ enjoy</h3>
<pre><code class="language-r">ggplot(data = mtcars) + 
  aes(x = wt, y = mpg) + 
  geom_point() + 
  geom_chull(alpha = .3)
</code></pre>
<p><img src="README__files/chunk-33-1.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(color = factor(am),
      fill = factor(am))
</code></pre>
<p><img src="README__files/chunk-33-2.png" alt="" /></p>
<hr />
<h2 id="sec-geom-waterfall-1-1-1-compute-panel-geomrect"><span class="section-number">4.5</span> geom_waterfall: <strong>1:1:1, compute_panel, GeomRect</strong></h2>
<p><em>One-row geom for each row in input dataset; geom interdependence</em></p>
<p>A waterfall plot displays inflows and outflows that occur as a result of events as well as the balance across multiple events. It is typically displayed as a series of rectangles.  Because the net change is displayed (cumulative change), there is interdependence between the geometries on our plot ‚Äì where one rectangle ends, the next in the series begins.   Therefore we‚Äôll be computing by <em>panel</em> and not by group ‚Äì we do not want ggplot2 to split the data by discrete variables, which our x axis is most likely to be.</p>
<!-- In this example we'll see how to alias the stat to a geom user-facing function (stat_waterfall -> geom_waterfall), and also how to change the geom to allow for additional convenient user-facing functions (stat_waterfall -> geom_waterfall_label).  We prep to create geom_waterfall label by using the default_aes slot in in the ggproto step.   -->
<h3 id="sec-step-0-use-base-ggplot2_4"><span class="section-number">4.5.1</span> Step 0. Use base ggplot2</h3>
<p>For ‚Äòstep 0‚Äô, we base ggplot2 to accomplish this task, and actually pretty closely follow Hadley Wickham‚Äôs short paper that tackles a waterfall plot with ggplot2. <a href="https://vita.had.co.nz/papers/ggplot2-wires.pdf">https://vita.had.co.nz/papers/ggplot2-wires.pdf</a></p>
<pre><code class="language-r">library(tidyverse)
flow_df &lt;- data.frame(event = c(&quot;Sales&quot;, 
                     &quot;Refunds&quot;,
                     &quot;Payouts&quot;, 
                     &quot;Court Losses&quot;, 
                     &quot;Court Wins&quot;, 
                     &quot;Contracts&quot;, 
                     &quot;Fees&quot;),
           change = c(6400, -1100, 
                      -100, -4200, 3800, 
                      1400, -2800)) %&gt;% 
  mutate(event = factor(event))

  
balance_df &lt;- flow_df %&gt;%   # maybe add factor in order if factor is not defined...
  mutate(x_pos = event %&gt;% as.numeric()) %&gt;% 
  arrange(x_pos) %&gt;% 
  mutate(balance = cumsum(c(0, 
                            change[-nrow(.)]))) %&gt;% 
  mutate(flow = factor(sign(change)))


ggplot(balance_df) +
          geom_rect(
            aes(x = event,
              xmin = x_pos - 0.45, 
              xmax = x_pos + 0.45, 
              ymin = balance, 
              ymax = balance + change)) +
  aes(fill = sign(change))
</code></pre>
<pre><code class="language-plain warning">#&gt; Ignoring unknown aesthetics: x
</code></pre>
<p><img src="README__files/chunk-34-1.png" alt="" /></p>
<h3 id="sec-steps-1-compute"><span class="section-number">4.5.2</span> Steps 1. compute</h3>
<p>Then, we bundle up this computation into a function (step 1), called compute_panel_waterfall.   We want the computation done <em>panel-wise</em> because of the interdependence between the events, which run along the x axis.  Group-wise computation (the defining compute_group element), would fail us, as the cross-event interdependence would not be preserved.</p>
<pre><code class="language-r">compute_panel_waterfall &lt;- function(data, scales, width = .90){
  
  data %&gt;% 
  arrange(x) %&gt;% 
  mutate(balance = cumsum(c(0, 
                            change[-nrow(.)]))) %&gt;% 
  mutate(direction = factor(sign(change))) %&gt;% 
  mutate(xmin = as.numeric(x) - width/2,
         xmax = as.numeric(x) + width/2,
         ymin = balance,
         ymax = balance + change) %&gt;% 
  # mutate(x = x_pos) %&gt;% 
  mutate(y = ymax) %&gt;% 
  mutate(gain_loss = ifelse(direction == 1, &quot;gain&quot;, &quot;loss&quot;))
  
}
</code></pre>
<h3 id="sec-step-2-define-stat-passing-to-ggproto"><span class="section-number">4.5.3</span> Step 2. Define Stat, passing to ggproto</h3>
<p>Now we‚Äôll pass the computation to the compute_panel‚Ä¶</p>
<pre><code class="language-r">StatWaterfall &lt;- ggplot2::ggproto(`_class` = &quot;StatWaterfall&quot;, 
                         `_inherit` = ggplot2::Stat,
                         required_aes = c(&quot;change&quot;, &quot;x&quot;),
                         compute_panel = compute_panel_waterfall)
</code></pre>
<h3 id="sec-step-3-pass-to-user-facing-function_1"><span class="section-number">4.5.4</span> Step 3. Pass to user-facing function</h3>
<p>In step 3, we define stat_waterfall, passing along StatWaterfall to create a ggplot2 layer function. We include a standard set of arguments, and we set the geom to ggplot2::GeomRect.</p>
<pre><code class="language-r">geom_waterfall &lt;- function(
  mapping = NULL,
  data = NULL,
  position = &quot;identity&quot;,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatWaterfall,  # proto object from step 2
    geom = ggplot2::GeomRect, 
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
</code></pre>
<h3 id="sec-step-4-use-test-enjoy_4"><span class="section-number">4.5.5</span> Step 4. Use/test/enjoy</h3>
<p>In Step 4, we get to try out the functionality.</p>
<pre><code class="language-r">flow_df |&gt; 
  ggplot() +
  geom_hline(yintercept = 0) +
  aes(change = change, 
      x = event) + # event in order
  geom_waterfall()
</code></pre>
<p><img src="README__files/chunk-38-1.png" alt="" /></p>
<h3 id="sec-bonus-default-aes-using-delayed-aesthetic-evaluation-d-a-e"><span class="section-number">4.5.6</span> Bonus: default <code>aes</code> using delayed aesthetic evaluation (D.A.E.)</h3>
<p>The bonus topic is on defining a default aesthetic.  In general, the direction of the flow is of great import for a waterfall chart, and it is typically depicted with fill color.  However, flow direction mapped to fill color might not be absolutely fundamental in how we conceive of a waterfall plot.  Therefore, instead of creating a variable ‚Äòfill‚Äô in the compute_panel_waterfall routine, we created gain_loss which we can reference with delayed aesthetic evaluation, in this case ggplot2::after_stat().  We‚Äôll refer to it in the <code>default_aes</code> slot of the StatWaterfall, using the ggplot2::after_stat() call on the internally created variable.</p>
<pre><code class="language-r">StatWaterfall &lt;- ggplot2::ggproto(`_class` = &quot;StatWaterfall&quot;, 
                         `_inherit` = ggplot2::Stat,
                         required_aes = c(&quot;change&quot;, &quot;x&quot;),
                         compute_panel = compute_panel_waterfall, 
                         default_aes =                              ### NEW!
                           ggplot2::aes(fill =
                                          ggplot2::after_stat(gain_loss)))
</code></pre>
<p>Now, since geom_waterfall calls StatWaterfall and we have added the default fill aesthetic, when we re-execute the code creating our plot, now we automatically get the direction of flow mapped to fill color.</p>
<pre><code class="language-r">flow_df |&gt; 
  ggplot() +
  geom_hline(yintercept = 0) +
  aes(change = change, 
      x = event) + # event in order
  geom_waterfall()
</code></pre>
<p><img src="README__files/chunk-40-1.png" alt="" /></p>
<p>However, we are not locked in to the gain_loss being the variable that defines fill, as seen below:</p>
<pre><code class="language-r">last_plot() + 
  aes(fill = event == &quot;Sales&quot;)
</code></pre>
<p><img src="README__files/chunk-41-1.png" alt="" /></p>
<p>And we can also turn off mapping to fill color by setting <code>aes(fill = NULL)</code>.</p>
<pre><code class="language-r">last_plot() + 
  aes(fill = NULL)
</code></pre>
<p><img src="README__files/chunk-42-1.png" alt="" /></p>
<h2 id="sec-geom-circlepack-1-1-n-compute-panel-geompolygon"><span class="section-number">4.6</span> geom_circlepack: <strong>1:1:n, compute_panel, GeomPolygon</strong></h2>
<p><em>a many-row geom for each row of the input data frame, with interdependence between input observations.</em></p>
<h3 id="sec-step-0-how-to-w-base-ggplot2-and-packcircles"><span class="section-number">4.6.1</span> Step 0. How-to w/ base ggplot2 (and {packcircles})</h3>
<pre><code class="language-r">df_to_plot &lt;- gapminder::gapminder %&gt;%  
  filter(continent == &quot;Americas&quot;) %&gt;%  
  filter(year == 2002) %&gt;%  
  select(country, pop)

packed_centers &lt;- packcircles::circleProgressiveLayout(
  df_to_plot$pop,  sizetype = 'area')  

circle_outlines &lt;- packed_centers %&gt;%  
  packcircles::circleLayoutVertices(npoints = 50)  
  
circle_outlines %&gt;%  
  ggplot() +  
  aes(x = x, y = y) +  
  geom_polygon() +  
  aes(group = id) + 
  coord_equal()
</code></pre>
<p><img src="README__files/chunk-43-1.png" alt="" /></p>
<h3 id="sec-step-1-compute_4"><span class="section-number">4.6.2</span> Step 1. Compute</h3>
<pre><code class="language-r"># Step 1
compute_panel_circlepack &lt;- function(data, scales){

  data_w_id &lt;- data |&gt;
    mutate(id = row_number())

  if(is.null(data$area)){

    data_w_id &lt;- data_w_id |&gt;
      mutate(area = 1)

  }

  data_w_id |&gt;
    pull(area) |&gt;
    packcircles::circleProgressiveLayout(
      sizetype = 'area') |&gt;
    packcircles::circleLayoutVertices(npoints = 50) |&gt;
    left_join(data_w_id) |&gt;
    mutate(group = id)

}
</code></pre>
<h3 id="sec-step-2-pass-to-ggproto-object_2"><span class="section-number">4.6.3</span> Step 2. pass to ggproto object</h3>
<pre><code class="language-r">StatCirclepack &lt;- ggplot2::ggproto(`_class` = &quot;StatCirclepack&quot;,
                                  `_inherit` = ggplot2::Stat,
                                  required_aes = c(&quot;id&quot;),
                                  compute_panel = compute_panel_circlepack#,
                                  # default_aes = ggplot2::aes(group = after_stat(id))
                                  )
</code></pre>
<h3 id="sec-step-3-pass-to-user-facing-function_2"><span class="section-number">4.6.4</span> Step 3. pass to user-facing function</h3>
<pre><code class="language-r">geom_circlepack &lt;- function(mapping = NULL, data = NULL,
                           position = &quot;identity&quot;, na.rm = FALSE,
                           show.legend = NA,
                           inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatCirclepack, # proto object from Step 2
    geom = ggplot2::GeomPolygon, # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
</code></pre>
<h3 id="sec-step-4-use-test-enjoy_5"><span class="section-number">4.6.5</span> Step 4. Use/test/enjoy</h3>
<pre><code class="language-r">gapminder::gapminder |&gt; 
  filter(year == 2002) |&gt; 
  ggplot() + 
  aes(id = country, area = pop/1000000) + 
  geom_circlepack() + 
  coord_equal()
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(id)`
</code></pre>
<p><img src="README__files/chunk-47-1.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(fill = continent)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(id)`
</code></pre>
<p><img src="README__files/chunk-47-2.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(fill = pop/1000000) + 
  facet_wrap(facets = vars(continent))
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(id)`Joining with `by = join_by(id)`Joining with `by = join_by(id)`Joining with `by = join_by(id)`Joining with `by = join_by(id)`
</code></pre>
<p><img src="README__files/chunk-47-3.png" alt="" /></p>
<h2 id="sec-geom-circle-1-1-n-compute-panel-geompolygon"><span class="section-number">4.7</span> geom_circle: <strong>1:1:n, compute_panel, GeomPolygon</strong></h2>
<p>This next example is the case that TLP took on in his talk, but takes a bit different approach to be more consistent with other approaches in this cookbook.  Essentially, for each row in our data set with defined centers x0 and y0 and radius r, we are joining up 15 rows which then help us build a circle around the x0y0 circle center.</p>
<p><em>a single row in a dataframe: will be visualized by a single mark : the mark will be defined by many-row in an internal dataframe</em></p>
<p><em>for each row in the dataframe, a single geometry is visualized, but each geometric mark is defined by many rows‚Ä¶</em></p>
<p>‚Äú../mytidytuesday/2023-12-27-geom_circle_via_join/geom_circle_via_join.Rmd‚Äù</p>
<h3 id="sec-step-0-do-it-with-base-ggplot2"><span class="section-number">4.7.1</span> Step 0. Do it with base ggplot2</h3>
<pre><code class="language-r">library(tidyverse)

n_vertices &lt;- 15

data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) |&gt; 
  mutate(input_data_row_id = row_number()) |&gt; 
  crossing(tibble(vertex_id = 0:n_vertices)) |&gt; 
  mutate(angle = 2*pi*vertex_id/max(vertex_id)) |&gt; 
  mutate(x = x0 + cos(angle)*r,
         y = y0 + sin(angle)*r) |&gt; 
  ggplot() + 
  aes(x, y) +
  geom_path(aes(group = input_data_row_id)) +
  geom_text(aes( label = vertex_id))
</code></pre>
<p><img src="README__files/chunk-48-1.png" alt="" /></p>
<h3 id="sec-step-1-compute_5"><span class="section-number">4.7.2</span> Step 1. Compute</h3>
<pre><code class="language-r">compute_panel_circle &lt;- function(data, scales, n_vertices = 15){
  
  data |&gt; 
    mutate(group = row_number()) |&gt; 
    crossing(tibble(vertex_id = 0:n_vertices)) |&gt;
    mutate(angle_in_circle = 2*pi*vertex_id/max(vertex_id)) |&gt; 
    mutate(x = x0 + cos(angle_in_circle)*r,
           y = y0 + sin(angle_in_circle)*r) 
  
}

tibble(x0 = 1:2, y0 = 1:2, r = 1 ) |&gt; 
  compute_panel_circle()
</code></pre>
<table>
<thead>
<tr>
<th align="right">x0</th>
<th align="right">y0</th>
<th align="right">r</th>
<th align="right">group</th>
<th align="right">vertex_id</th>
<th align="right">angle_in_circle</th>
<th align="right">x</th>
<th align="right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0.000</td>
<td align="right">2.000</td>
<td align="right">1.000</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0.419</td>
<td align="right">1.914</td>
<td align="right">1.407</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">0.838</td>
<td align="right">1.669</td>
<td align="right">1.743</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">1.257</td>
<td align="right">1.309</td>
<td align="right">1.951</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">1.676</td>
<td align="right">0.895</td>
<td align="right">1.995</td>
</tr>
<tr>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">11</td>
<td align="right">4.608</td>
<td align="right">1.895</td>
<td align="right">1.005</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">12</td>
<td align="right">5.027</td>
<td align="right">2.309</td>
<td align="right">1.049</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">13</td>
<td align="right">5.445</td>
<td align="right">2.669</td>
<td align="right">1.257</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">14</td>
<td align="right">5.864</td>
<td align="right">2.914</td>
<td align="right">1.593</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">15</td>
<td align="right">6.283</td>
<td align="right">3.000</td>
<td align="right">2.000</td>
</tr>
</tbody>
</table>
<h3 id="sec-step-2-pass-to-ggproto_3"><span class="section-number">4.7.3</span> Step 2. Pass to ggproto</h3>
<pre><code class="language-r">StatCircle &lt;- ggproto(
  `_class` = &quot;StatCircle&quot;, 
  `_inherit` = ggplot2::Stat,
  compute_panel = compute_panel_circle,
                      required_aes = c(&quot;x0&quot;, &quot;y0&quot;, &quot;r&quot;)
                      )
</code></pre>
<h3 id="sec-step-3-write-geom-or-stat"><span class="section-number">4.7.4</span> Step 3. Write geom_* or stat_*</h3>
<pre><code class="language-r">geom_circle &lt;- function(
  mapping = NULL,
  data = NULL,
  position = &quot;identity&quot;,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatCircle,  # proto object from Step 2
    geom = ggplot2::GeomPolygon,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
</code></pre>
<h3 id="sec-step-4-enjoy-test"><span class="section-number">4.7.5</span> Step 4: Enjoy (test)</h3>
<pre><code class="language-r">data.frame(x0 = 0:1, 
           y0 = 0:1, 
           r = 1:2/3) |&gt; 
  ggplot() + 
  aes(x0 = x0, y0 = y0, r = r) + 
  geom_circle(color = &quot;red&quot;,
              linetype = &quot;dashed&quot;) + 
  aes(fill = r)
</code></pre>
<p><img src="README__files/chunk-52-1.png" alt="" /></p>
<pre><code class="language-r">diamonds |&gt; 
  slice_sample(n = 80) |&gt; 
  ggplot() + 
  aes(x0 = as.numeric(cut), 
      y0 = carat, 
      r = as.numeric(clarity)/20) + 
  geom_circle(alpha = .2, n_vertices = 5) + 
  aes(fill = after_stat(r)) +
  coord_equal()
</code></pre>
<p><img src="README__files/chunk-52-2.png" alt="" /></p>
<pre><code class="language-r">cars |&gt; 
  sample_n(12) |&gt;  
  ggplot() + 
  aes(x0 = speed, y0 = dist, r = dist/speed) + 
  geom_circle(color = &quot;black&quot;) +
  coord_equal()
</code></pre>
<p><img src="README__files/chunk-52-3.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(alpha = speed &gt; 15) +
  aes(linetype = dist &gt; 20) +
  aes(fill = speed &gt; 18) +
  facet_wrap(~ dist &gt; 40)
</code></pre>
<pre><code class="language-plain warning">#&gt; Using alpha for a discrete variable is not advised.
</code></pre>
<p><img src="README__files/chunk-52-4.png" alt="" /></p>
<h3 id="sec-discussion-why-not-compute-group"><span class="section-number">4.7.6</span> Discussion: Why not compute_group</h3>
<pre><code class="language-r">StatCircle2 &lt;- ggproto(
  `_class` = &quot;StatCircle2&quot;,
  `_inherit` = ggplot2::Stat,
  compute_group = compute_panel_circle,
  required_aes = c(&quot;x0&quot;, &quot;y0&quot;, &quot;r&quot;))

geom_circle_CG &lt;- function(
  mapping = NULL,
  data = NULL,
  position = &quot;identity&quot;,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatCircle2,  # proto object from Step 2
    geom = ggplot2::GeomPolygon,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}

cars |&gt; 
  sample_n(12) |&gt;  
  ggplot() + 
  aes(x0 = speed, y0 = dist, r = dist/speed) + 
  geom_circle_CG(color = &quot;black&quot;) +
  coord_equal() + 
  aes(alpha = speed &gt; 15) +
  aes(linetype = dist &gt; 20) +
  aes(fill = speed &gt; 18) +
  facet_wrap(~ dist &gt; 40)
</code></pre>
<pre><code class="language-plain warning">#&gt; Using alpha for a discrete variable is not advised.
</code></pre>
<p><img src="README__files/chunk-53-1.png" alt="" /></p>
<pre><code class="language-r">
</code></pre>
<h3 id="sec-exercise-write-the-function-geom-heart-that-will-take-the-compute-below-and-do-it-within-the-geom-function"><span class="section-number">4.7.7</span> Exercise: Write the function, geom_heart() that will take the compute below and do it within the geom_* function</h3>
<pre><code class="language-r">data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) %&gt;% 
  mutate(group = row_number()) %&gt;% 
  tidyr::crossing(vertex_index = 0:15/15) %&gt;%
    dplyr::mutate(
      y = y0 + r * (
        .85 * cos(2*pi*vertex_index)
        - .35 * cos(2 * 2*pi*vertex_index)
        - .25 * cos(3 * 2*pi*vertex_index)
        - .05 * cos(4 * 2*pi*vertex_index)
      ),
      x = x0 + r * (sin(2*pi*vertex_index)^3)) %&gt;% 
  ggplot() +
   aes(x = x, y = y, group = group) + 
  geom_polygon(alpha = .5, fill = &quot;darkred&quot;) + 
  coord_equal()
</code></pre>
<p><img src="README__files/chunk-54-1.png" alt="" /></p>
<h2 id="sec-geom-state-1-1-n-compute-panel-geompolygon"><span class="section-number">4.8</span> geom_state: <strong>1:1:n, compute_panel, GeomPolygon</strong></h2>
<h3 id="sec-step-0-use-base-ggplot2_5"><span class="section-number">4.8.1</span> Step 0:  use base ggplot2</h3>
<pre><code class="language-r">states_characteristics &lt;- tibble(state.name) |&gt; 
  mutate(ind_vowel_states = 
           str_detect(state.name, &quot;A|E|I|O|U&quot;))

head(states_characteristics)
</code></pre>
<table>
<thead>
<tr>
<th>state.name</th>
<th>ind_vowel_states</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alabama</td>
<td>TRUE</td>
</tr>
<tr>
<td>Alaska</td>
<td>TRUE</td>
</tr>
<tr>
<td>Arizona</td>
<td>TRUE</td>
</tr>
<tr>
<td>Arkansas</td>
<td>TRUE</td>
</tr>
<tr>
<td>California</td>
<td>FALSE</td>
</tr>
<tr>
<td>Colorado</td>
<td>FALSE</td>
</tr>
</tbody>
</table>
<pre><code class="language-r">us_states_geo &lt;- ggplot2::map_data(&quot;state&quot;)

head(us_states_geo)
</code></pre>
<table>
<thead>
<tr>
<th align="right">long</th>
<th align="right">lat</th>
<th align="right">group</th>
<th align="right">order</th>
<th>region</th>
<th>subregion</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">-87.462</td>
<td align="right">30.390</td>
<td align="right">1</td>
<td align="right">1</td>
<td>alabama</td>
<td></td>
</tr>
<tr>
<td align="right">-87.485</td>
<td align="right">30.372</td>
<td align="right">1</td>
<td align="right">2</td>
<td>alabama</td>
<td></td>
</tr>
<tr>
<td align="right">-87.525</td>
<td align="right">30.372</td>
<td align="right">1</td>
<td align="right">3</td>
<td>alabama</td>
<td></td>
</tr>
<tr>
<td align="right">-87.531</td>
<td align="right">30.332</td>
<td align="right">1</td>
<td align="right">4</td>
<td>alabama</td>
<td></td>
</tr>
<tr>
<td align="right">-87.571</td>
<td align="right">30.327</td>
<td align="right">1</td>
<td align="right">5</td>
<td>alabama</td>
<td></td>
</tr>
<tr>
<td align="right">-87.588</td>
<td align="right">30.327</td>
<td align="right">1</td>
<td align="right">6</td>
<td>alabama</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-r">states_characteristics |&gt; 
  left_join(us_states_geo |&gt; mutate(state.name = stringr::str_to_title(region))) |&gt; 
  ggplot() + 
  aes(x = long, y = lat, group = group) +
  geom_polygon() +
  aes(fill = ind_vowel_states) +
  coord_map()
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(state.name)`
</code></pre>
<p><img src="README__files/chunk-55-1.png" alt="" /></p>
<h3 id="sec-step-1-write-compute-function_2"><span class="section-number">4.8.2</span> Step 1:  Write compute function üöß</h3>
<h4 id="sec-prestep-prepare-reference-dataset-with-state-perimeters"><span class="section-number">4.8.2.1</span> Prestep. Prepare reference dataset with state perimeters</h4>
<pre><code class="language-r">ggplot2::map_data(&quot;state&quot;) |&gt; 
  rename(state_name = region) |&gt; 
  mutate(state_name = stringr::str_to_title(state_name)) |&gt; 
  rename(x = long, y = lat) |&gt; 
  select(-subregion) |&gt; 
  rename(state_id_number = group) -&gt;
continental_states_geo_reference
</code></pre>
<h4 id="sec-compute-step-join-reference-data-onto-input-data"><span class="section-number">4.8.2.2</span> Compute step.  Join reference data onto input data</h4>
<pre><code class="language-r">compute_panel_state &lt;- function(data, scales){
  
  data |&gt; 
    dplyr::left_join(continental_states_geo_reference) |&gt;
    dplyr::mutate(group = state_id_number)
  
}
</code></pre>
<p>And let‚Äôs test out this compute‚Ä¶</p>
<pre><code class="language-r">states_characteristics |&gt; 
  rename(state_name = state.name) |&gt; 
  compute_panel_state()
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(state_name)`
</code></pre>
<table>
<thead>
<tr>
<th>state_name</th>
<th>ind_vowel_states</th>
<th align="right">x</th>
<th align="right">y</th>
<th align="right">state_id_number</th>
<th align="right">order</th>
<th align="right">group</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alabama</td>
<td>TRUE</td>
<td align="right">-87.462</td>
<td align="right">30.390</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr>
<td>Alabama</td>
<td>TRUE</td>
<td align="right">-87.485</td>
<td align="right">30.372</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">1</td>
</tr>
<tr>
<td>Alabama</td>
<td>TRUE</td>
<td align="right">-87.525</td>
<td align="right">30.372</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">1</td>
</tr>
<tr>
<td>Alabama</td>
<td>TRUE</td>
<td align="right">-87.531</td>
<td align="right">30.332</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">1</td>
</tr>
<tr>
<td>Alabama</td>
<td>TRUE</td>
<td align="right">-87.571</td>
<td align="right">30.327</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">1</td>
</tr>
<tr>
<td>‚ãÆ</td>
<td>‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
<td align="right">‚ãÆ</td>
</tr>
<tr>
<td>Wyoming</td>
<td>FALSE</td>
<td align="right">-106.857</td>
<td align="right">41.012</td>
<td align="right">63</td>
<td align="right">15595</td>
<td align="right">63</td>
</tr>
<tr>
<td>Wyoming</td>
<td>FALSE</td>
<td align="right">-107.309</td>
<td align="right">41.018</td>
<td align="right">63</td>
<td align="right">15596</td>
<td align="right">63</td>
</tr>
<tr>
<td>Wyoming</td>
<td>FALSE</td>
<td align="right">-107.922</td>
<td align="right">41.018</td>
<td align="right">63</td>
<td align="right">15597</td>
<td align="right">63</td>
</tr>
<tr>
<td>Wyoming</td>
<td>FALSE</td>
<td align="right">-109.057</td>
<td align="right">40.989</td>
<td align="right">63</td>
<td align="right">15598</td>
<td align="right">63</td>
</tr>
<tr>
<td>Wyoming</td>
<td>FALSE</td>
<td align="right">-109.051</td>
<td align="right">40.995</td>
<td align="right">63</td>
<td align="right">15599</td>
<td align="right">63</td>
</tr>
</tbody>
</table>
<h3 id="sec-step-2-pass-to-ggproto_4"><span class="section-number">4.8.3</span> Step 2. Pass to ggproto</h3>
<pre><code class="language-r">StatUsstate &lt;- ggplot2::ggproto(`_class` = &quot;StatUsstate&quot;,
                                `_inherit` = ggplot2::Stat,
                                required_aes = c(&quot;state_name&quot;),
                                compute_panel = compute_panel_state)
</code></pre>
<h3 id="sec-step-3-pass-to-user-facing-function_3"><span class="section-number">4.8.4</span> Step 3. Pass to user-facing function</h3>
<pre><code class="language-r">geom_state &lt;- function(mapping = NULL, data = NULL,
                           position = &quot;identity&quot;, na.rm = FALSE,
                           show.legend = NA,
                           inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatUsstate, # proto object from Step 2
    geom = ggplot2::GeomPolygon, # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
</code></pre>
<h3 id="sec-step-4-use-test-enjoy_6"><span class="section-number">4.8.5</span> Step 4. Use/Test/Enjoy</h3>
<pre><code class="language-r">ggplot(data = states_characteristics) + 
  aes(state_name = state.name) +
  geom_state() + 
  coord_map()
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(state_name)`
</code></pre>
<p><img src="README__files/chunk-61-1.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(fill = ind_vowel_states)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(state_name)`
</code></pre>
<p><img src="README__files/chunk-61-2.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(fill = state.name == &quot;Iowa&quot;)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(state_name)`
</code></pre>
<p><img src="README__files/chunk-61-3.png" alt="" /></p>
<h2 id="sec-geom-ols-linear-parallel-n-k-w-interdependence"><span class="section-number">4.9</span> geom_ols_linear_parallel: <strong>n:k:w; interdependence</strong></h2>
<p>If you‚Äôre a long time user of ggplot2, you‚Äôll probably have used geom_smooth. However, because geom_smooth estimates group-wise, that is, the modeling is done in the  compute_group step of the Stat‚Äôs specification, when a categorical variable is mapped (to color or group for example), multiple models are computed and visualized. When you want to visualize a single model that contain a categorical (discrete) variable, then, geom_smooth won‚Äôt be well suited to your problem.</p>
<p>To start to think about extension in this space, we create geom_ols_linear_parallel, the simple case of an OLS model with a continuous and categorical independent variables, with no interaction and no higher order terms. This simple extension could be widely useful in in teaching and industry. Yet, this is a very specific use case; in the bonus material we‚Äôll discuss in how the extension strategy could be made usable for more modeling cases.</p>
<h3 id="sec-step-1-get-the-job-done-with-ggplot2"><span class="section-number">4.9.1</span> Step 1. Get the job done with ggplot2</h3>
<pre><code class="language-r">penguins_df &lt;- palmerpenguins::penguins |&gt;
  ggplot2::remove_missing()
</code></pre>
<pre><code class="language-plain warning">#&gt; Removed 11 rows containing missing values or values outside the scale range.
</code></pre>
<pre><code class="language-r">model_bill_length &lt;- lm(bill_length_mm ~ 
                        bill_depth_mm + species, 
                        data = penguins_df)

penguins_df |&gt;
  mutate(bill_length_fit =
           model_bill_length$fitted.values) |&gt;
  ggplot() +
  aes(x = bill_depth_mm,
      y = bill_length_mm) +
  geom_point() + 
  aes(color = species) + 
  geom_line(aes(y = bill_length_fit))
</code></pre>
<p><img src="README__files/chunk-62-1.png" alt="" /></p>
<pre><code class="language-r">compute_panel_lm_parallel &lt;- function(data, scales){
  
  model &lt;- lm(y ~ x + category, data = data)
  
  data |&gt;
    mutate(y = model$fitted)
  
}
</code></pre>
<h3 id="sec-step-2-pass-compute-to-ggproto-object"><span class="section-number">4.9.2</span> Step 2. Pass compute to ggproto object</h3>
<pre><code class="language-r">StatParallel &lt;- ggplot2::ggproto(`_class` = &quot;StatParallel&quot;,
                           `_inherit` = ggplot2::Stat,
                           required_aes = c(&quot;x&quot;, &quot;y&quot;, &quot;category&quot;),
                           compute_panel = compute_panel_lm_parallel,
                           default_aes = aes(color = after_stat(category)))
</code></pre>
<h3 id="sec-step-3-pass-to-user-facing-function_4"><span class="section-number">4.9.3</span> Step 3. Pass to user-facing function</h3>
<pre><code class="language-r">geom_ols_linear_parallel &lt;- function(mapping = NULL, data = NULL,
                           position = &quot;identity&quot;, na.rm = FALSE,
                           show.legend = NA,
                           inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatParallel, # proto object from Step 2
    geom = ggplot2::GeomLine, # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
</code></pre>
<h3 id="sec-step-4-use-test-enjoy_7"><span class="section-number">4.9.4</span> Step 4. Use/test/enjoy</h3>
<pre><code class="language-r">ggplot(palmerpenguins::penguins) +
  aes(x = bill_depth_mm, 
      y = bill_length_mm,
      color = species, 
      category = species) +
  geom_point() + 
  geom_ols_linear_parallel()
</code></pre>
<pre><code class="language-plain warning">#&gt; Removed 2 rows containing non-finite outside the scale range (`stat_parallel()`).
#&gt; Removed 2 rows containing missing values or values outside the scale range (`geom_point()`).
</code></pre>
<p><img src="README__files/chunk-66-1.png" alt="" /></p>
<h2 id="sec-geom-county-1-1-1-compute-panel-geomsf"><span class="section-number">4.10</span> geom_county: <em><em>1:1:1</em>, compute_panel, GeomSf</em>*</h2>
<p><em>a geom defined by an sf geometry column</em></p>
<h3 id="sec-step-0-get-it-done-in-base-ggplot2"><span class="section-number">4.10.1</span> Step 0. get it done in base ggplot2</h3>
<p>Similar to our U.S. states example, where the state name is the positional aesthetic‚Ä¶</p>
<pre><code class="language-r"># data to visualize
# nc_county_info |&gt; head()

# find a dataset with geographic info
nc_geo_reference &lt;- sf::st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;)) |&gt; 
  select(NAME, FIPS, FIPSNO, geometry)
</code></pre>
<pre><code>#&gt; Reading layer `nc' from data source 
#&gt;   `/Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/library/sf/shape/nc.shp' 
#&gt;   using driver `ESRI Shapefile'
#&gt; Simple feature collection with 100 features and 14 fields
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965
#&gt; Geodetic CRS:  NAD27
</code></pre>
<pre><code class="language-r">nc_geo_reference |&gt; 
  rename(fips = FIPS) |&gt; 
  full_join(ggnorthcarolina::northcarolina_county_flat) |&gt; 
  ggplot() + 
  geom_sf() + 
  aes(fill = BIR79)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(fips, FIPSNO)`
</code></pre>
<p><img src="README__files/chunk-68-1.png" alt="" /></p>
<h3 id="sec-step-1-compute_6"><span class="section-number">4.10.2</span> Step 1. compute</h3>
<h4 id="sec-prestep-prepare-reference-sf-dataframe"><span class="section-number">4.10.2.1</span> Prestep. Prepare reference sf dataframe</h4>
<p>Our objective is similar to the geom_state() construction that uses a reference dataframe that contains the latitudes and longitudes of the state perimeters in the compute step; the reference data is joined up via the state_name required aesthetic. Then we inherit geom behavior from GeomPolygon.</p>
<p>The sf layer approach is similar.  Instead of adding many rows of data for each locality with longitude and latitude coordinates, however, the geometry list-column will be added in the compute step.</p>
<p>If we inspect the layer data for the choropleth created with base ggplot2, we see the geometry column and fill which will be familiar to you if you‚Äôve done any work with geom_sf().  However, you‚Äôll also note the xmin, xmax, ymin, and ymax columns.  These are also needed for our reference data.</p>
<p>So‚Ä¶ This is my question to the ggplot2 and spatial folks.  Below, I have a routine for adding these xmin ymin etc columns.  Do you have a better one?  Perhaps something that uses a ggplot2 sf internal function?</p>
<pre><code class="language-r">last_plot() |&gt; layer_data() |&gt; head()
</code></pre>
<table>
<thead>
<tr>
<th>fill</th>
<th>geometry</th>
<th>PANEL</th>
<th align="right">group</th>
<th align="right">xmin</th>
<th align="right">xmax</th>
<th align="right">ymin</th>
<th align="right">ymax</th>
<th align="right">linetype</th>
<th>alpha</th>
<th align="right">stroke</th>
</tr>
</thead>
<tbody>
<tr>
<td>#152F48</td>
<td>MULTIPOLYGON (((-81.47276 3‚Ä¶</td>
<td>1</td>
<td align="right">-1</td>
<td align="right">-84.324</td>
<td align="right">-75.457</td>
<td align="right">33.882</td>
<td align="right">36.59</td>
<td align="right">1</td>
<td></td>
<td align="right">0.5</td>
</tr>
<tr>
<td>#132C44</td>
<td>MULTIPOLYGON (((-81.23989 3‚Ä¶</td>
<td>1</td>
<td align="right">-1</td>
<td align="right">-84.324</td>
<td align="right">-75.457</td>
<td align="right">33.882</td>
<td align="right">36.59</td>
<td align="right">1</td>
<td></td>
<td align="right">0.5</td>
</tr>
<tr>
<td>#1A3854</td>
<td>MULTIPOLYGON (((-80.45634 3‚Ä¶</td>
<td>1</td>
<td align="right">-1</td>
<td align="right">-84.324</td>
<td align="right">-75.457</td>
<td align="right">33.882</td>
<td align="right">36.59</td>
<td align="right">1</td>
<td></td>
<td align="right">0.5</td>
</tr>
<tr>
<td>#142D46</td>
<td>MULTIPOLYGON (((-76.00897 3‚Ä¶</td>
<td>1</td>
<td align="right">-1</td>
<td align="right">-84.324</td>
<td align="right">-75.457</td>
<td align="right">33.882</td>
<td align="right">36.59</td>
<td align="right">1</td>
<td></td>
<td align="right">0.5</td>
</tr>
<tr>
<td>#16304A</td>
<td>MULTIPOLYGON (((-77.21767 3‚Ä¶</td>
<td>1</td>
<td align="right">-1</td>
<td align="right">-84.324</td>
<td align="right">-75.457</td>
<td align="right">33.882</td>
<td align="right">36.59</td>
<td align="right">1</td>
<td></td>
<td align="right">0.5</td>
</tr>
<tr>
<td>#16314B</td>
<td>MULTIPOLYGON (((-76.74506 3‚Ä¶</td>
<td>1</td>
<td align="right">-1</td>
<td align="right">-84.324</td>
<td align="right">-75.457</td>
<td align="right">33.882</td>
<td align="right">36.59</td>
<td align="right">1</td>
<td></td>
<td align="right">0.5</td>
</tr>
</tbody>
</table>
<pre><code class="language-r">
</code></pre>
<pre><code class="language-r">### 1, create sf reference dataframe w xmin, ymin, xmax and ymax using return_st_bbox_df function
return_st_bbox_df &lt;- function(sf_df){
  
  bb &lt;- sf::st_bbox(sf_df)

  data.frame(xmin = bb[1], ymin = bb[2],
             xmax = bb[3], ymax = bb[4])

}

northcarolina_county_reference &lt;-
  sf::st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;)) |&gt;
  dplyr::rename(county_name = NAME,
                fips = FIPS) |&gt;
  dplyr::select(county_name, fips, geometry) |&gt;
  dplyr::mutate(bb =
                  purrr::map(geometry,
                             return_st_bbox_df)) |&gt;
  tidyr::unnest(bb) |&gt;
  data.frame()
</code></pre>
<pre><code>#&gt; Reading layer `nc' from data source 
#&gt;   `/Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/library/sf/shape/nc.shp' 
#&gt;   using driver `ESRI Shapefile'
#&gt; Simple feature collection with 100 features and 14 fields
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965
#&gt; Geodetic CRS:  NAD27
</code></pre>
<h4 id="sec-compute-step-using-reference-data"><span class="section-number">4.10.2.2</span> Compute Step using reference data</h4>
<pre><code class="language-r">compute_panel_county &lt;- function(data, scales){
  
  data |&gt; 
    dplyr::inner_join(northcarolina_county_reference)
  
}
</code></pre>
<h3 id="sec-step-2-pass-to-ggproto-object_3"><span class="section-number">4.10.3</span> Step 2. pass to ggproto object</h3>
<pre><code class="language-r">StatNcfips &lt;- ggplot2::ggproto(`_class` = &quot;StatNcfips&quot;,
                                `_inherit` = ggplot2::Stat,
                                required_aes = &quot;fips|county_name&quot;,
                                compute_panel = compute_panel_county)
</code></pre>
<h3 id="sec-step-3-pass-to-user-facing-function-wrapping-ggplot-layer-sf-instead-of-ggplot2-layer-more-check-with-crss"><span class="section-number">4.10.4</span> Step 3. pass to user-facing function (wrapping ggplot::layer_sf() instead of ggplot2::layer())  üöß <em>more check with CRSs</em></h3>
<pre><code class="language-r">geom_county &lt;- function(
      mapping = NULL,
      data = NULL,
      position = &quot;identity&quot;,
      na.rm = FALSE,
      show.legend = NA,
      inherit.aes = TRUE,
      crs = &quot;NAD27&quot;, # &quot;NAD27&quot;, 5070, &quot;WGS84&quot;, &quot;NAD83&quot;, 4326 , 3857
      ...) {

  c(ggplot2::layer_sf(
              stat = StatNcfips,  # proto object from step 2
              geom = ggplot2::GeomSf,  # inherit other behavior
              data = data,
              mapping = mapping,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = rlang::list2(na.rm = na.rm, ...)
              ),
              
              coord_sf(crs = crs,
                       default_crs = sf::st_crs(crs),
                       datum = crs,
                       default = TRUE)
     )
  }
</code></pre>
<h3 id="sec-step-4-use-test-enjoy_8"><span class="section-number">4.10.5</span> Step 4. Use/test/enjoy!</h3>
<pre><code class="language-r">ggnorthcarolina::northcarolina_county_flat |&gt; 
  ggplot() + 
  aes(fips = fips) + 
  geom_county(crs = &quot;NAD83&quot;)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(fips)`
</code></pre>
<p><img src="README__files/chunk-74-1.png" alt="" /></p>
<pre><code class="language-r">p &lt;- last_plot()
p$coordinates$crs
</code></pre>
<pre><code>#&gt; [1] &quot;NAD83&quot;
</code></pre>
<pre><code class="language-r">last_plot() + 
  aes(fill = SID74/BIR74)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(fips)`
</code></pre>
<p><img src="README__files/chunk-74-2.png" alt="" /></p>
<pre><code class="language-r">
</code></pre>
<h2 id="sec-geom-county-label-1-1-1-geomtext"><span class="section-number">4.11</span> geom_county_label: **1:1:1; GeomText **</h2>
<pre><code class="language-r">nc_geo_reference |&gt; 
  rename(fips = FIPS) |&gt; 
  full_join(ggnorthcarolina::northcarolina_county_flat) |&gt; 
  ggplot() + 
  # geom_sf() + 
  aes(fill = BIR79) + 
  geom_sf_text(aes(label = NAME), 
               check_overlap = T,
               color = &quot;gray80&quot;)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(fips, FIPSNO)`
</code></pre>
<pre><code class="language-plain warning">#&gt; st_point_on_surface may not give correct results for longitude/latitude data
</code></pre>
<p><img src="README__files/chunk-75-1.png" alt="" /></p>
<h3 id="sec-step-1-compute_7"><span class="section-number">4.11.1</span> Step 1 compute</h3>
<p>Prestep.</p>
<pre><code class="language-r">northcarolina_county_reference |&gt;
    dplyr::pull(geometry) |&gt;
    sf::st_zm() |&gt;
    sf::st_point_on_surface() -&gt;
  points_sf
</code></pre>
<pre><code class="language-plain warning">#&gt; st_point_on_surface may not give correct results for longitude/latitude data
</code></pre>
<pre><code class="language-r">#https://github.com/r-spatial/sf/issues/231
the_coords &lt;- do.call(rbind, sf::st_geometry(points_sf)) %&gt;%
  tibble::as_tibble() %&gt;% setNames(c(&quot;x&quot;,&quot;y&quot;))


nc_geo_reference_w_center_coords &lt;- cbind(northcarolina_county_reference, the_coords)
</code></pre>
<pre><code class="language-r">compute_panel_county_label &lt;- function(data, scales){
  
  data |&gt;
    dplyr::inner_join(nc_geo_reference_w_center_coords) 
    

}
</code></pre>
<h3 id="sec-step-2_1"><span class="section-number">4.11.2</span> Step 2</h3>
<pre><code class="language-r">StatNcfipslabel &lt;- ggplot2::ggproto(`_class` = &quot;StatNcfipslabel&quot;,
                                `_inherit` = ggplot2::Stat,
                                required_aes = &quot;fips|county_name&quot;,
                                compute_panel = compute_panel_county_label,
                               default_aes = 
                                 aes(label = after_stat(county_name)))
</code></pre>
<h3 id="sec-step-3_1"><span class="section-number">4.11.3</span> Step 3</h3>
<pre><code class="language-r">geom_county_label &lt;- function(
      mapping = NULL,
      data = NULL,
      position = &quot;identity&quot;,
      na.rm = FALSE,
      show.legend = NA,
      inherit.aes = TRUE,
      crs = &quot;NAD27&quot;, # &quot;NAD27&quot;, 5070, &quot;WGS84&quot;, &quot;NAD83&quot;, 4326 , 3857
      ...) {

  c(ggplot2::layer_sf(
              stat = StatNcfipslabel,  # proto object from step 2
              geom = ggplot2::GeomText,  # inherit other behavior
              data = data,
              mapping = mapping,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = rlang::list2(na.rm = na.rm, ...)
              ),
              
              coord_sf(crs = crs,
                       default_crs = sf::st_crs(crs),
                       datum = crs,
                       default = TRUE)
     )
  }
</code></pre>
<h3 id="sec-step-4"><span class="section-number">4.11.4</span> Step 4</h3>
<pre><code class="language-r">nc_county_info |&gt;
  ggplot() + 
  aes(fips = fips) +
  geom_county_label(size = 3)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(fips)`
</code></pre>
<p><img src="README__files/chunk-80-1.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(label = BIR79) + 
  geom_county(alpha = .2)
</code></pre>
<pre><code class="language-plain message">#&gt; Joining with `by = join_by(fips)`Joining with `by = join_by(fips)`
</code></pre>
<p><img src="README__files/chunk-80-2.png" alt="" /></p>
<h3 id="sec-exercise_1"><span class="section-number">4.11.5</span> Exercise</h3>
<p>Use a <em>common</em> STAT to create geom_estado and geom_estado_label</p>
<pre><code class="language-r">geo_ref_data_raw &lt;- rnaturalearth::ne_countries(  
  scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) %&gt;%  
  select(name, continent, geometry) %&gt;% 
  rename(country_name = name)
</code></pre>
<h3 id="sec-exercise_2"><span class="section-number">4.11.6</span> Exercise</h3>
<p>Use sf data to create another set of useful layers for making choropleths</p>
<pre><code class="language-r">
</code></pre>
<h2 id="sec-geom-candlestick-summarize-first-then-interdependence"><span class="section-number">4.12</span> geom_candlestick summarize first, then interdependence ‚Ä¶</h2>
<!-- ## geom_pie: **n -> 1:1:1** -->
<!-- ```{r} -->
<!-- code = readlines_wo_roxygen("../ggwedge/R/compute_panel_pie.R") -->
<!-- ``` -->
<!-- ## geom_wedge: **n -> 1:1:n** -->
<h1 id="sec-stat-layers-keeping-flexible-via-stat-functions"><span class="section-number main-number">5</span> stat_* layers: keeping flexible via stat_* functions</h1>
<h2 id="sec-stat-chull-n-1-n-compute-group-geompolygon-geomtext-geompoint"><span class="section-number">5.1</span> stat_chull: <strong>N:1:n; compute_group; GeomPolygon, GeomText, GeomPoint</strong></h2>
<p>Rather than defining geom functions, you might instead write stat_* functions which can be used with a variety of geoms.  Let‚Äôs contrast geom_chull and stat_chull below.</p>
<pre><code class="language-r">geom_chull &lt;- function(mapping = NULL, 
                        data = NULL,
                        position = &quot;identity&quot;, 
                        na.rm = FALSE, 
                        show.legend = NA,
                        inherit.aes = TRUE, ...) {

  ggplot2::layer(
    stat = StatChull, 
    geom = ggplot2::GeomPolygon, 
    data = data, mapping = mapping,
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )

}


stat_chull &lt;- function(mapping = NULL, 
                       geom = ggplot2::GeomPolygon, 
                       data = NULL,
                       position = &quot;identity&quot;, 
                       na.rm = FALSE, 
                       show.legend = NA,
                       inherit.aes = TRUE, ...) {

  ggplot2::layer(
    stat = StatChull, 
    geom = geom, 
    data = data, 
    mapping = mapping,
    position = position, 
    show.legend = show.legend, 
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )

}
</code></pre>
<p>The construction is almost identical.  However, in the stat version, the geom is flexible because it can be user defined, instead of being hard-coded in the function.  Its use allows you to go in different visual directions, but might have a higher cognitive load.</p>
<pre><code class="language-r">p &lt;- ggplot(data = mtcars) + 
  aes(x = wt, y = mpg) + 
  geom_point() 

p +
  stat_chull(alpha = .3)
</code></pre>
<p><img src="README__files/chunk-85-1.png" alt="" /></p>
<pre><code class="language-r">p +
  stat_chull(geom = &quot;point&quot;,
             color = &quot;red&quot;,
             size = 4)
</code></pre>
<p><img src="README__files/chunk-85-2.png" alt="" /></p>
<pre><code class="language-r">p + 
  stat_chull(geom = &quot;text&quot;,
             label = &quot;c-hull point&quot;,
             hjust = 0)
</code></pre>
<p><img src="README__files/chunk-85-3.png" alt="" /></p>
<pre><code class="language-r"># shows stat does not well-serve &quot;path&quot; geom
p + 
  stat_chull(geom = &quot;path&quot;,
             label = &quot;c-hull point&quot;,
             hjust = 0)
</code></pre>
<pre><code class="language-plain warning">#&gt; Ignoring unknown parameters: `label` and `hjust`
</code></pre>
<p><img src="README__files/chunk-85-4.png" alt="" /></p>
<h2 id="sec-stat-waterfall-1-1-1-compute-panel-geomrect-geomtext"><span class="section-number">5.2</span> stat_waterfall: <strong>1:1:1; compute_panel; GeomRect, GeomText</strong></h2>
<p>Now, we also return to the waterfall question. Let‚Äôs see how we can prepare the same stat to serve both with GeomRect and GeomText to write user-facing functions. In brief, we‚Äôll create a stat_* user-facing function which doesn‚Äôt hard-code our geom, but has the default GeomRect.  We‚Äôll alias stat_waterfall to geom_* waterfall, and also create geom_waterfall_text for labeling the rectangle-based layer.</p>
<pre><code class="language-r">StatWaterfall &lt;- ggplot2::ggproto(`_class` = &quot;StatWaterfall&quot;, 
                         `_inherit` = ggplot2::Stat,
                         required_aes = c(&quot;change&quot;, &quot;x&quot;),
                         compute_panel = compute_panel_waterfall,
                         default_aes = ggplot2::aes(label = ggplot2::after_stat(change),
                                           fill = ggplot2::after_stat(gain_loss),
                                           vjust = ggplot2::after_stat((direction == -1) %&gt;%
                                                                as.numeric)))

stat_waterfall &lt;- function(geom = ggplot2::GeomRect, 
  mapping = NULL,
  data = NULL,
  position = &quot;identity&quot;,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatWaterfall,  # proto object from step 2
    geom = geom,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}

geom_waterfall &lt;- stat_waterfall

geom_waterfall_label &lt;- function(..., lineheight = .8){
  stat_waterfall(geom = &quot;text&quot;, 
                 lineheight = lineheight, ...)}

flow_df |&gt; 
  ggplot() +
  geom_hline(yintercept = 0) +
  aes(change = change, 
      x = event) + # event in order
  geom_waterfall() + 
  geom_waterfall_label()
</code></pre>
<p><img src="README__files/chunk-86-1.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(x = fct_reorder(event, change))
</code></pre>
<p><img src="README__files/chunk-86-2.png" alt="" /></p>
<pre><code class="language-r">last_plot() + 
  aes(x = fct_reorder(event, abs(change)))
</code></pre>
<p><img src="README__files/chunk-86-3.png" alt="" /></p>
<h2 id="sec-bonus-part-2-dae-with-geomtext-target"><span class="section-number">5.3</span> Bonus part 2. DAE with GeomText target</h2>
<p>If you‚Äôve still got some stamina, let‚Äôs talk about another great usage of DEA in Stat definitions: for default label definitions.  Below, we overwrite the StatWaterfall default_aes yet again, with the default fill aes defined, but also the label and vjust aes, which are relevant to labeling.</p>
<p>Then we define a separate user-facing function geom_waterfall_label, based on the same stat.</p>
<pre><code class="language-r">StatWaterfall$default_aes &lt;- ggplot2::aes(fill = ggplot2::after_stat(gain_loss),
                                          label = ggplot2::after_stat(change),
                                          vjust = ggplot2::after_stat((direction == -1) %&gt;%
                                                                        as.numeric))

geom_waterfall_label &lt;- function(
  mapping = NULL,
  data = NULL,
  position = &quot;identity&quot;,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatWaterfall,  # proto object from step 2
    geom = ggplot2::GeomText, 
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}

flow_df |&gt; 
  ggplot() +
  geom_hline(yintercept = 0) +
  aes(change = change, 
      x = event) + # event in order
  geom_waterfall() + 
  geom_waterfall_label()
</code></pre>
<p><img src="README__files/chunk-87-1.png" alt="" /></p>
<pre><code class="language-r">
</code></pre>
<p>The final plot shows that while there are some convenience defaults for label and fill, these can be over-ridden.</p>
<pre><code class="language-r">last_plot() + 
  aes(label = ifelse(change &gt; 0, &quot;gain&quot;, &quot;loss&quot;)) + 
  aes(fill = NULL)
</code></pre>
<p><img src="README__files/chunk-88-1.png" alt="" /></p>
<h1 id="sec-piggyback-on-compute"><span class="section-number main-number">6</span> Piggyback on compute</h1>
<h2 id="sec-some-delayed-aesthetic-evaluation"><span class="section-number">6.1</span> Some Delayed Aesthetic Evaluation</h2>
<h2 id="sec-borrowing-compute"><span class="section-number">6.2</span> Borrowing compute</h2>
<h2 id="sec-geom-smoothfit-1-1-1-ggproto-piggybacking-on-compute"><span class="section-number">6.3</span> geom_smoothfit: <strong>1:1:1</strong> ggproto piggybacking on compute‚Ä¶</h2>
<p>n:1:80 is geom_smooth default.</p>
<pre><code class="language-r">ggplot(data = mtcars) +
  aes(x = wt, y = mpg) +
  geom_point() +
  geom_smooth() +
  stat_smooth(xseq = mtcars$wt,
              geom = &quot;point&quot;,
              color = &quot;blue&quot;)
</code></pre>
<pre><code class="language-plain message">#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
</code></pre>
<p><img src="README__files/chunk-89-1.png" alt="" /></p>
<h3 id="sec-step-1-compute_8"><span class="section-number">6.3.1</span> Step 1. compute</h3>
<pre><code class="language-r">compute_group_smooth_fit &lt;- function(data, scales, method = NULL, formula = NULL,
                           se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                           level = 0.95, method.args = list(),
                           na.rm = FALSE, flipped_aes = NA){
  
  
  out &lt;- ggplot2::StatSmooth$compute_group(data = data, scales = scales, 
                       method = method, formula = formula, 
                       se = FALSE, n= n, span = span, fullrange = fullrange,
                       xseq = data$x, 
                       level = .95, method.args = method.args, 
                       na.rm = na.rm, flipped_aes = flipped_aes) 
  

  out$x_obs &lt;-  data$x
  out$y_obs &lt;- data$y
  
  out$xend &lt;- out$x_obs
  out$yend &lt;- out$y_obs
  
  out
  
}
</code></pre>
<h3 id="sec-step-2_2"><span class="section-number">6.3.2</span> Step 2</h3>
<h3 id="sec-step-3_2"><span class="section-number">6.3.3</span> Step 3</h3>
<pre><code class="language-r">
</code></pre>
<h2 id="sec-add-default-aesthetics"><span class="section-number">6.4</span> add default aesthetics</h2>
<h2 id="sec-geom-barlab-adding-defaults-to-existing-stats-via-ggproto-editing"><span class="section-number">6.5</span> geom_barlab:  Adding defaults to existing stats via ggproto editing</h2>
<pre><code class="language-r">
</code></pre>
<h1 id="sec-facet-sample"><span class="section-number main-number">7</span> facet_sample</h1>
<h1 id="sec-theme-chalkboard"><span class="section-number main-number">8</span> theme_chalkboard()</h1>
<pre><code class="language-r">theme_chalkboard &lt;- function(board_color = &quot;darkseagreen4&quot;,
                             chalk_color = &quot;lightyellow&quot;, ...){

  ggplot2::theme_gray(...) %+replace%   ##&lt;&lt; we'll piggy back on an existing theme
    ggplot2::theme(
      rect = ggplot2::element_rect(fill = board_color,
                                   color = board_color),
      text = ggplot2::element_text(color = chalk_color,
                                   face = &quot;italic&quot;,
                                   size = 18),
      panel.background = ggplot2::element_rect(fill = board_color,
                                               color = board_color),
      axis.text = ggplot2::element_text(color = chalk_color),
      axis.ticks = ggplot2::element_line(color = chalk_color),
      panel.grid = ggplot2::element_blank(),
      complete = TRUE   ##&lt;&lt; important, see 20.1.2 Complete themes in ggplot2 book
      )

}

theme_chalkboard_slate &lt;- function(){

  theme_chalkboard(&quot;lightskyblue4&quot;, &quot;honeydew&quot;)

}
</code></pre>
<pre><code class="language-r">ggplot(data = cars) +
  aes(x = speed, dist) +
  geom_point() +
  theme_chalkboard()
</code></pre>
<p><img src="README__files/chunk-94-1.png" alt="" /></p>
<pre><code class="language-r">last_plot() +
  theme_chalkboard_slate()
</code></pre>
<p><img src="README__files/chunk-94-2.png" alt="" /></p>
<pre><code class="language-r">
</code></pre>
<p>See ggchalkboard for geoms_chalk_on() and geoms_chalk_off().</p>
<h1 id="sec-coords"><span class="section-number main-number">9</span> Coords</h1>
<h2 id="sec-coord-page"><span class="section-number">9.1</span> coord_page()</h2>
<p>One easily created new coord function is the coord_page(). Here we just wrap the coord_trans function and setting y to be reversed.  Therefore, our coordinate system will be set up more like a note page where we count lines from top to bottom instead of a Cartesian coordinate system which counts from bottom to top.</p>
<pre><code class="language-r">coord_page &lt;- function(...){
  
  coord_trans(y = &quot;reverse&quot;, ...)
  
}
</code></pre>
<h1 id="sec-coord-poster"><span class="section-number main-number">10</span> coord_poster()</h1>
<p>Similar to the properties of coord_page(), our aim with creating coord_poster() is to have vertical positioning go from top to bottom, but also to have the aspect ratio to be 1 (horizontal 1 unit is equal to one vertical move).  It‚Äôs between coord_equal() X coord_page()</p>
<pre><code class="language-r">coord_equal
</code></pre>
<pre><code>#&gt; function (ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, 
#&gt;     clip = &quot;on&quot;) 
#&gt; {
#&gt;     check_coord_limits(xlim)
#&gt;     check_coord_limits(ylim)
#&gt;     ggproto(NULL, CoordFixed, limits = list(x = xlim, y = ylim), 
#&gt;         ratio = ratio, expand = expand, clip = clip)
#&gt; }
#&gt; &lt;bytecode: 0x7f8f7ad6d808&gt;
#&gt; &lt;environment: namespace:ggplot2&gt;
</code></pre>
<pre><code class="language-r">CoordCartesian$transform
</code></pre>
<pre><code>#&gt; &lt;ggproto method&gt;
#&gt;   &lt;Wrapper function&gt;
#&gt;     function (...) 
#&gt; transform(...)
#&gt; 
#&gt;   &lt;Inner function (f)&gt;
#&gt;     function (data, panel_params) 
#&gt; {
#&gt;     data &lt;- transform_position(data, panel_params$x$rescale, 
#&gt;         panel_params$y$rescale)
#&gt;     transform_position(data, squish_infinite, squish_infinite)
#&gt; }
</code></pre>
<pre><code class="language-r">CoordCartesian$aspect
</code></pre>
<pre><code>#&gt; &lt;ggproto method&gt;
#&gt;   &lt;Wrapper function&gt;
#&gt;     function (...) 
#&gt; aspect(...)
#&gt; 
#&gt;   &lt;Inner function (f)&gt;
#&gt;     function (ranges) 
#&gt; NULL
</code></pre>
<pre><code class="language-r">CoordCartesian$range
</code></pre>
<pre><code>#&gt; &lt;ggproto method&gt;
#&gt;   &lt;Wrapper function&gt;
#&gt;     function (...) 
#&gt; range(...)
#&gt; 
#&gt;   &lt;Inner function (f)&gt;
#&gt;     function (panel_params) 
#&gt; {
#&gt;     list(x = panel_params$x$dimension(), y = panel_params$y$dimension())
#&gt; }
</code></pre>
<pre><code class="language-r">CoordFixed$is_free
</code></pre>
<pre><code>#&gt; &lt;ggproto method&gt;
#&gt;   &lt;Wrapper function&gt;
#&gt;     function (...) 
#&gt; is_free(...)
#&gt; 
#&gt;   &lt;Inner function (f)&gt;
#&gt;     function () 
#&gt; FALSE
</code></pre>
<h1 id="sec-modified-start-points-ggverbatim"><span class="section-number main-number">11</span> modified start points; ggverbatim(),</h1>
<h2 id="sec-ggverbatim"><span class="section-number">11.1</span> ggverbatim()</h2>
<pre><code class="language-r">readlines_wo_roxygen(&quot;../ggverbatim/R/ggverbatim.R&quot;)
</code></pre>
<pre><code>#&gt;  [1] &quot;ggverbatim &lt;- function(data, cat_cols = 1,  row_var_name = NULL, cols_var_name = \&quot;x\&quot;, value_var_name = NULL){&quot;       
#&gt;  [2] &quot;&quot;                                                                                                                      
#&gt;  [3] &quot;  message(\&quot;Variables that represented visually are ; e.g.  aesthetic mappying are 'x', and \&quot; |&gt; paste(row_var_name))&quot;
#&gt;  [4] &quot;&quot;                                                                                                                      
#&gt;  [5] &quot;  row_var_name &lt;- names(data)[1]&quot;                                                                                      
#&gt;  [6] &quot;  names(data)[1] &lt;- \&quot;row_var\&quot;&quot;                                                                                       
#&gt;  [7] &quot;&quot;                                                                                                                      
#&gt;  [8] &quot;  col_headers &lt;- names(data)&quot;                                                                                          
#&gt;  [9] &quot;  col_headers &lt;- col_headers[2:length(col_headers)]&quot;                                                                   
#&gt; [10] &quot;&quot;                                                                                                                      
#&gt; [11] &quot;  data %&gt;%&quot;                                                                                                            
#&gt; [12] &quot;    mutate(row_var = fct_inorder(row_var)) %&gt;%&quot;                                                                        
#&gt; [13] &quot;    pivot_longer(cols = -cat_cols) %&gt;%&quot;                                                                                
#&gt; [14] &quot;    mutate(name = factor(name, levels = col_headers)) %&gt;%&quot;                                                             
#&gt; [15] &quot;    rename(x = name) -&gt;&quot;                                                                                               
#&gt; [16] &quot;  pivoted&quot;                                                                                                             
#&gt; [17] &quot;&quot;                                                                                                                      
#&gt; [18] &quot;  pivoted %&gt;%&quot;                                                                                                         
#&gt; [19] &quot;    ggplot() +&quot;                                                                                                        
#&gt; [20] &quot;    aes(x = x) +&quot;                                                                                                      
#&gt; [21] &quot;    labs(x = cols_var_name) +&quot;                                                                                         
#&gt; [22] &quot;    aes(y = row_var) +&quot;                                                                                                
#&gt; [23] &quot;    labs(y = row_var_name) +&quot;                                                                                          
#&gt; [24] &quot;    aes(label = value) +&quot;                                                                                              
#&gt; [25] &quot;    aes(fill = value) +&quot;                                                                                               
#&gt; [26] &quot;    scale_x_discrete(position = \&quot;top\&quot;) +&quot;                                                                            
#&gt; [27] &quot;    scale_y_discrete(limits=rev)&quot;                                                                                      
#&gt; [28] &quot;&quot;                                                                                                                      
#&gt; [29] &quot;}&quot;                                                                                                                     
</code></pre>
<h1 id="sec-ggedgelist"><span class="section-number main-number">12</span> ggedgelist()</h1>
<pre><code class="language-r"># get into ggplot2 plot space from edge list data frame 
ggedgelist &lt;- function(edgelist, nodelist = NULL, ...)(
  
  # message(&quot;'name' a variable created in the 'nodes' dataframe&quot;)
  
    if(is.null(nodelist)){
    edgelist %&gt;% 
    tidygraph::as_tbl_graph() %&gt;% 
    ggraph::ggraph(...) 
    
  }else{ # join on nodes attributes if they are available
    
    names(nodelist)[1] &lt;- &quot;name&quot;
    
    edgelist %&gt;% 
    tidygraph::as_tbl_graph() %&gt;%
    dplyr::full_join(nodelist) %&gt;% 
    ggraph::ggraph(...) 
    
  }
  
)

# get a fill viz w edgelist dataframe only
ggedgelist_quick &lt;- function(edgelist, nodelist = NULL, include_names = F,  ...){
  

  p &lt;- ggedgelist(edgelist = edgelist,
                  nodelist = nodelist, ...) +
  ggraph::geom_edge_link(color = &quot;orange&quot;) +
  ggraph::geom_node_point(size = 9,
                  color = &quot;steelblue&quot;,
                  alpha = .8) 
  
  if(include_names){p + ggraph::geom_node_label(aes(label = name))}else{p}
  
}

geom_node_label_auto &lt;- function(...){ 
  
  ggraph::geom_node_label(aes(label = name), ...)
  
}

geom_node_text_auto &lt;- function(...){ 
  
  ggraph::geom_node_text(aes(label = name), ...)
  
}
</code></pre>
<h2 id="sec-ggscatterplot-rearrangement"><span class="section-number">12.1</span> ggscatterplot(), rearrangement</h2>
<pre><code class="language-r">
</code></pre>
<h1 id="sec-wrapping-fiddly-functions-annotate-and-theme"><span class="section-number main-number">13</span> wrapping fiddly functions (annotate and theme)</h1>
<p><a href="https://github.com/EvaMaeRey/ggstamp">https://github.com/EvaMaeRey/ggstamp</a></p>
<p><a href="https://github.com/EvaMaeRey/more_theme_easing_ideas">https://github.com/EvaMaeRey/more_theme_easing_ideas</a></p>
<h1 id="sec-make-it-a-package-ggtedious-formal-testing"><span class="section-number main-number">14</span> make it a package:  ggtedious <em>formal testing</em></h1>
<p>This is a placeholder for the ggtedious workshop, yet to be completed.</p>
<p><a href="https://github.com/EvaMaeRey/ggtedious">https://github.com/EvaMaeRey/ggtedious</a></p>
<pre><code class="language-r">#library(ggtedius)
</code></pre>
<div class="chapter-after side side-right">
<p>Source: <code>../ggplot2-extension-cookbook/README.Rmd</code></p>
</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.12.14/js/sidenotes.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.12.14/js/appendix.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.12.14/js/toc-highlight.min.js" defer></script>
</body>
</html>
