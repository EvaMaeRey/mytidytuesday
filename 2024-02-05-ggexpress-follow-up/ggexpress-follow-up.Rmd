---
title: "gg express"
author: "Evangeline Reynolds"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(tidyverse.quiet = TRUE)
```




## gg express? why abbreviate syntax for new layers where computation is performed under the hood...

[ggtemp/ggexpress](https://github.com/EvaMaeRey/ggtemp) project exists because syntax to generate new layer seems a little more verbose and not proportionate to what you are trying to accomplish.

I've learned other people think would be nice to have lighter syntax layer creation, and have worked on this problem, including Elio Campitelli who writes about his similar motivation: 

> But still, creating a geom from scratch is an involved process that doesn‚Äôt lend itself to simple transformations. -- Elio Campitelli  

The Spanish is slightly different, and maybe a little more to the point: 

> Pero a√∫n as√≠, hacer un stat espec√≠fico cada vez que uno quiere hacer un plot en particular es demasiado complicado.*

I worked with stat_rasa() - it is good!  It seems very similar to the ggtemp goals and implementation.  I think ggtemp might be coming from something that looks more like the full, standard extension syntax, and then maybe you'd be more positioned to migrate to that? 

I also heard about https://github.com/mjskay/ggbuilder from June Choe and think that is about even stat modulations right in the plot build?  Redefine compute internals on the fly?  I'm not sure. 

I also include some code Teun Van Der Brand offered on piping, but to be honest, practical implications and connection to this problem are not yet clear to me. üò≠

Progessing with ggtemp::define_layer_temp(), I tried to make some changes to make the internal code more compact... but I think (hope) my ggplot2::stat knowledge is failing me, and hope there is a solution.  I want to make all the relevant ggproto slots accesible, setting NULL as default, and then filling them in with Stat$compute_group, or what have you if you user doesn't define the slot.  The StatRasa implementation has the function working in compute_group only, whereas I think there would be a lot of interest in a function that works in compute panel arena. 

I worked on a project with ggtemp and it was fun!  I think more fun than it would have been w/ traditional syntax. https://github.com/EvaMaeRey/ggcircleof5ths


## Campitelli:  stat_rasa {.tabset}

https://eliocamp.github.io/codigo-r/en/2018/05/how-to-make-a-generic-stat-in-ggplot2/

### Backend StatRasa, stat_rasa() 

```{r cars}
library(tidyverse)

StatRasa <- ggplot2::ggproto("StatRasa", ggplot2::Stat,
  compute_group = function(data, scales, fun, fun.args) {
     # Change default arguments of the function to the 
     # values in fun.args
     args <- formals(fun)
     for (i in seq_along(fun.args)) {
        if (names(fun.args[i]) %in% names(fun.args)) {
           args[[names(fun.args[i])]] <- fun.args[[i]]
        } 
     }
     formals(fun) <- args
     
     # Apply function to data
     fun(data)
})

# stat function used in ggplot
stat_rasa <- function(mapping = NULL, data = NULL,
                      geom = "point", 
                      position = "identity",
                      fun = NULL,
                      ...,
                      show.legend = NA,
                      inherit.aes = TRUE) {
   # Check arguments 
   if (!is.function(fun)) stop("fun must be a function")
   
   # Pass dotted arguments to a list
   fun.args <- match.call(expand.dots = FALSE)$`...`
   
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = StatRasa,
      geom = geom,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      check.aes = FALSE,
      check.param = FALSE,
      params = list(
         fun = fun, 
         fun.args = fun.args,
         na.rm = FALSE,
         ...
      )
   )
}
```

### UI, stat_rasa(fun = detrend)

```{r}
# using .75 span to match ggplot2 geom_smooth
Detrend <- function(data, method = "lm", span = 0.75) {
   if (method == "lm") {
      data$y <- resid(lm(y ~ x, data = data))
   } else {
      data$y <- resid(loess(y ~ x, span = span, data = data))
   }
   as.data.frame(data)
   }
   
   
library(ggplot2)
set.seed(42)
x <- seq(-1, 3, length.out = 30)
y <- x^2 + rnorm(30)*0.5
df <- data.frame(x = x, y = y)

ggplot(df, aes(x, y)) +
  geom_line(aes(color = "raw data")) +
  geom_smooth(aes(color = "loess smoothing"),
              alpha = .3) + 
  stat_smooth(geom = "point", 
              aes(color = "loess smoothing"),
              xseq = df$x) +
  stat_rasa(geom = "line", 
             fun = Detrend, 
             method = "smooth",
             aes(color = "detrended")) +
  geom_hline(yintercept = 0, 
             linetype = "dashed") + 
  scale_color_discrete(breaks = 
                         fct_inorder(c("raw data",
                                       "loess smoothing",
                                       "detrended"))) +
  labs(title = "detrending with loess smoothing")
```  
  
### UI, stat_rasa -> stat_detrend
  
```{r}  
stat_detrend <- function(...) {
   stat_rasa(fun = Detrend, geom = "line", ...)
}

ggplot(df, aes(x, y)) + 
  geom_line(aes(color = "raw data")) +
  geom_smooth(method = "lm", 
              aes(color = "linear model")) +
  stat_smooth(method = "lm", geom = "segment",
              xend = df$x, yend = df$y,
              xseq = df$x, alpha = .2
              ) +
  stat_detrend(method = "lm", 
                aes(color = "detrended")) +
  geom_hline(yintercept = 0, 
             linetype = "dashed") + 
  scale_color_discrete(breaks = 
                         fct_inorder(c("raw data",
                                       "linear model",
                                       "detrended"))) + 
  labs(title = "Linear detrending",
       color = NULL)
```

### stat_rasa(fun = summarize_xy)

```{r}
summarize_xy <- function(data, sum_fun = mean){
  
  data |>
    summarize(
      x = sum_fun(x),
      y = sum_fun(y)
    )
  
}


mtcars |>
  ggplot() + 
  aes(x = wt,
      y = mpg) + 
  geom_point() + 
  stat_rasa(fun = summarize_xy, 
            size = 8,
            aes(color = "means")) + 
  stat_rasa(fun = summarize_xy, 
            sum_fun = median, 
            size = 8, 
            aes(color = "medians")) + 
  labs(color = "centroid")

```


## ggtemp: define_layer_temp and concision troubles{.tabset}

### Backend ggtemp:::define_layer_temp()

```{r}
ggtemp:::define_layer_temp
```

### Backend ggtemp:::create_layer_temp()


```{r}
ggtemp:::create_layer_temp
```


### UI: define_layer_temp()

```{r}
compute_panel_circle <- function(data, scales, n_vertices = 15){
  
  data |> 
    mutate(group = row_number()) |> 
    crossing(tibble(z = 0:n_vertices)) |>
    mutate(around = 2*pi*z/max(z)) |> 
    mutate(x = x0 + cos(around)*r,
           y = y0 + sin(around)*r) 
  
}

geom_circle <- function(...){
  
  ggtemp:::define_layer_temp(
  compute_panel = compute_panel_circle,
  required_aes = c("x0", "y0"),
    ...)
  
}

library(ggplot2)
data.frame(x0 = 0:1, y0 = 0:1, r = 1:2/3) |>
  ggplot() +
  aes(x0 = x0, y0 = y0, r = r) +
  geom_circle(n_vertices = 5) +
  aes(fill = r)
```


### UI: ggtemp:::create_layer_temp()


```{r}
compute_group_xy_summary <- function(data, scales){
  
  data |> 
    summarize(x = mean(x),
              y = mean(y))
  
}

ggtemp:::create_layer_temp("geom_xy_summary",
    compute_group = compute_group_xy_summary,
    required_aes = c("x", "y"))
  

mtcars |>
  ggplot() +
  aes(x = wt, y = mpg) +
  geom_point() + 
  geom_xy_summary(size = 8)

last_plot() + 
  aes(color = factor(gear))


```

### Backend rewrite attempt..

This is giving me more problems; I thought I would be able to start with a lot of null elements, and use generic slot fillers like ggplot2::Stat$compute_panel... But strategy doesn't seem to be working.

```{r}
define_layer_temp <- function(
  compute_group = NULL,
  compute_panel = NULL, 
  required_aes = NULL,
  geom = ggplot2::GeomPoint, 
  mapping = NULL,
  data = NULL,
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, 
  ...) {

  if(is.null(compute_group)){compute_group <- ggplot2::Stat$compute_group}
  if(is.null(compute_panel)){compute_panel <- ggplot2::Stat$compute_panel}
  if(is.null(required_aes)) {required_aes  <- ggplot2::Stat$required_aes}
     
     
StatTemp <- ggproto(
  `_class` = "StatTemp",
  `_inherit` = ggplot2::Stat,
  compute_group = compute_group,
  compute_panel = compute_panel,
  required_aes  = required_aes
  )
  
  ggplot2::layer(
    stat = StatTemp,  # proto object from Step 2
    geom = geom,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```


# stat_rasa X ggtemp?

- allow functions to work in compute_group, compute_panel, compute_layer slot
- write functions such that they can be used in more standard extension syntax
- write (danger?) create_* function w/ assign()




## On the fly Stat mutation?

ggbuilder https://github.com/mjskay/ggbuilder and pipe note might have something to do with more dynamic, on-the-fly internal data manipulation and stat creation...

```{r}

```



### pipe note from Teun vd Brand



```{r}
library(tidyverse)
piped <- . %>% summarise(x = mean(x)) %>%
  mutate(x = x + 1)

piped

magrittr::functions(piped)

```




## Closing remarks, Other Relevant Work, Caveats
