---
title: "choropleths w/ same data+where+layer construction"
author: "Evangeline Reynolds"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = T)
options(tidyverse.quiet = TRUE)
```




## Intro Thoughts


## Status Quo

```{r}
library(tidyverse)
library(ozmaps)

# some data that we want to viz
au_states <- tribble(~state, ~pop,
        "Victoria", 1,
        "Queensland", 2,
        "New South Wales", 3,
        "Western Australia", 4,
        "Northern Territory", 5,
        "Tasmania", 6,
        "South Australia", 7,
        "Australian Capital Territory", 8,
        "Other Territories", 9
        )

sf_oz <- ozmap("states")

sf_oz |> names()

sf_oz |>
  full_join(au_states, by = join_by(NAME == state )) |> 
  ggplot() + 
  geom_sf() +
  aes(fill = pop)
```


# But awkward, so... Step 1. Compute

```{r}
australia_state_ref <- sf_oz |>
  select(state_name = NAME)


compute_panel_regions <- function(data = au_states, scales, ref_data = australia_state_ref, keep = NULL, drop = NULL, stamp = F){

ref_data$id <- ref_data[1][[1]]

if(!is.null(keep)){ref_data <- ref_data |> filter(id %in% keep)}
if(!is.null(drop)){ref_data <- ref_data |> filter(!(id %in% drop))}

ref_data <- ref_data |> 
    ggplot2::StatSf$compute_panel(coord = ggplot2::CoordSf) |>
    ggplot2::StatSfCoordinates$compute_group(coord = ggplot2::CoordSf)

if(!stamp){ ref_data |> inner_join(data) } else { ref_data }

}
```


# Test Compute

```{r}
au_states |> 
  rename(state_name = state) |>
  compute_panel_regions()

ggplot(au_states) +
  aes(state_name = state) +
  geom_sf(stat = ggproto(NULL, Stat, 
                         compute_panel = compute_panel_regions)) + 
  aes(fill = pop)
```

# Step 2. Define Stat

```{r}
StatRegion <- ggproto("StatRegion",
                        Stat,
                        compute_panel = compute_panel_regions,
                        default_aes = aes(label = after_stat(id)))
```

# Test Stat

```{r}
ggplot(au_states) +
  aes(state_name = state) +
  geom_sf(stat = StatRegion) + 
  geom_text(stat = StatRegion) +
  aes(fill = pop)
```


# Step 3. Define user facing function w/ `make_constructor`... But: coord_sf must be added separately

```{r}
geom_au_state <- make_constructor(GeomSf, stat = StatRegion, ref_data = australia_state_ref)
geom_au_state_text <- make_constructor(GeomText, stat = StatRegion, ref_data = australia_state_ref)

crs_au_states <- sf::st_crs(sf_oz)

ggplot(au_states) +
  aes(state_name = state) + 
  geom_state() + # errors without coord_sf, and needs the right one
  geom_state_text(check_overlap = T, size = 2) + 
  aes(fill = pop) +
  coord_sf(crs = crs_au_states)

```


# Step 3.0.1 make geom_region0 (no coords) and friends w/ `make_constructor`... and geom_region (w/ coords)... and friends.


```{r, eval = T, error = T}
geom_region0 <- make_constructor(GeomSf, stat = StatRegion) # no crs
geom_region_text0 <- make_constructor(GeomText, stat = StatRegion) # no crs
stamp_region0 <- make_constructor(GeomSf, stat = StatRegion, stamp = T, inherit.aes = F) # no crs
stamp_region_text0 <- make_constructor(GeomText, stat = StatRegion, stamp = T, inherit.aes = F) # no crs
```


# Test things out with pass the dots argument 

```{r}
# all the arguments should be passed
geom_region <- function(..., ref_data){
  c(geom_region0(..., ref_data = ref_data), 
    coord_sf(crs = sf::st_crs(ref_data)))
}

geom_region_text <- function(..., ref_data){
  c(geom_region_text0(..., ref_data = ref_data), 
    coord_sf(crs = sf::st_crs(ref_data)))
}
```

# Step 4. make region-specific user-facing functions!

```{r}
# all arguments above that should be passed, could be passed, or, 
geom_states <- function(...){geom_region(..., ref_data = australia_state_ref)}
geom_states_text <- function(...){geom_region_text(..., ref_data = australia_state_ref)}
```

# test!

```{r}
au_states |>
  ggplot() +
  aes(state_name = state,
      fill = pop) + 
  geom_states() +
  geom_states(keep = "Western Australia", 
              color = "red",
              fill = NA) +
  geom_states_text() + 
  geom_states(stamp = T,
              keep = "Tasmania", 
              fill = "orange")

au_states |>
  ggplot() +
  aes(state_name = state) + 
  geom_states(aes(fill = pop))

  
```

# epiloge, something nicer for for geom_region -> geom_province, geom_state, etc?  `specify_geom_region()`

```{r}
geom_region0

# all the arguments should be passed
geom_region <- function(mapping = NULL, data = NULL, stat = StatRegion, position = "identity", ..., legend = NULL, lineend = "butt", linejoin = "round", 
    linemitre = 10, arrow = NULL, arrow.fill = NULL, na.rm = FALSE, 
    show.legend = NA, inherit.aes = TRUE, ref_data){
  
  c(geom_region0(mapping = mapping, data = data, geom = "sf", stat = stat, 
        position = position, show.legend = show.legend, inherit.aes = inherit.aes, 
        params = list2(na.rm = na.rm, legend = legend, lineend = lineend, 
            linejoin = linejoin, linemitre = linemitre, arrow = arrow, 
            arrow.fill = arrow.fill, ..., ref_data = ref_data)), 
    coord_sf(crs = sf::st_crs(ref_data)))
  
}


geom_au_state <- purrr::partial(geom_region, ref_data = australia_state_ref)


clone_w_fixed <- function(original_function, arg_name, fixed_value) {
  orig_formals <- formals(original_function)
  new_formals <- orig_formals
  new_formals[[arg_name]] <- NULL

  call_args <- lapply(names(orig_formals), function(an) {
    if (an == arg_name) fixed_value
    else if (an == "...") quote(...)
    else as.symbol(an)
  })
  names(call_args) <- names(orig_formals)
  call_expr <- as.call(c(list(original_function), call_args))

  new_func <- function() {}
  formals(new_func) <- new_formals
  body(new_func) <- call_expr
  environment(new_func) <- environment(original_function)
  return(new_func)
}

# Example Usage:
my_original_function <- function(x, y = 10, z, verbose = FALSE){ x * y + z }
my_fixed_y_function <- clone_w_fixed(my_original_function, "y", 5)

geom_region


my_fixed_y_function

# Test:
my_fixed_y_function(x = 2, z = 4) # Returns 14 (2*5+4)
formals(my_fixed_y_function) # Shows x, z, verbose


clone_w_fixed <- function(func_expr, arg_name, fixed_value, env = parent.frame()) {

  # Capture the expression for the original function (e.g., `my_original_function`)
  # This will be used directly in the body of the new function for clean printing.
  func_symbol_or_expr <- substitute(func_expr)

  # Evaluate the expression to get the actual function object.
  # This is used to extract formals and the function's environment.
  original_function <- eval(func_symbol_or_expr, envir = env)

  orig_formals <- formals(original_function)
  new_formals <- orig_formals
  new_formals[[arg_name]] <- NULL # Remove the fixed argument from the new function's signature

  # Construct the arguments for the internal call to the original function
  call_args <- lapply(names(orig_formals), function(an) {
    if (an == arg_name) fixed_value
    else if (an == "...") quote(...) # Pass along '...' if present
    else as.symbol(an)                # Pass other arguments by their name
  })
  names(call_args) <- names(orig_formals) # Preserve argument names

  # Create the actual call expression for the body.
  # Use the captured symbol/expression for cleaner printing.
  call_expr <- as.call(c(list(func_symbol_or_expr), call_args))

  # Create the new function
  new_func <- function() {} # Placeholder function
  formals(new_func) <- new_formals
  body(new_func) <- call_expr

  # Set the environment of the new function to that of the original function.
  # This ensures the new function can find the original function (by its symbol).
  environment(new_func) <- environment(original_function)

  return(new_func)
}

# --- Example Usage ---

# Define an original function
my_original_function <- function(x, y = 10, z, verbose = FALSE, ...) {
  result <- x * y + z + sum(...)
  if (verbose) {
    message(paste("Calculating:", x, "*", y, "+", z, "+ sum(...) =", result))
  }
  return(result)
}

# Clone it, fixing 'y' to 5
my_fixed_y_function <- clone_w_fixed(my_original_function, "y", 5)

# Observe the output:
print(my_fixed_y_function)
# function (x, z, verbose = FALSE, ...)
# my_original_function(x = x, y = 5, z = z, verbose = verbose, ...)

# Test the new function
my_fixed_y_function(x = 2, z = 4)
# [1] 14 (2*5+4)
my_fixed_y_function(x = 2, z = 4, 100, verbose = TRUE)
# Calculating: 2 * 5 + 4 + sum(...) = 114
# [1] 114


ggplot(cars) + 
  labs(x = "hello") + 
  aes(x = speed)


```

## Closing remarks, Other Relevant Work, Caveats
