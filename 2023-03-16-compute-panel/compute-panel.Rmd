---
title: "Compute Panel"
author: "Evangeline Reynolds"
date: "3/16/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:


---
class: inverse, middle, center

# Recipe #1

--

##`geom_point_xy_medians()`

--

- This will be a point at the median of x and y


---
class: inverse, middle, center

## Step 0: use base ggplot2 to get the job done

---




```{r penguins}
library(tidyverse)
library(palmerpenguins)

penguins <- remove_missing(penguins)

model <- lm(body_mass_g ~ flipper_length_mm + species, data = penguins)

penguins %>% 
  mutate(fitted = model$fitted.values) ->
penguins_w_fitted

penguins_w_fitted %>% 
  ggplot() + 
  aes(x = flipper_length_mm) + 
  aes(y = body_mass_g) + 
  aes(color = species) +
  geom_point() + 
  geom_line(aes(y = fitted, group = species))
```


## Step 1: computation



- define computation that ggplot2 should do for you, before plotting
  - here it's computing a variable with labels for each observation
- test that functionality!






```{r compute_panel_ols_ind}
compute_panel_ols_ind <- function(data, scales, formula = y ~ x + indicator) {

  model <- lm(formula = formula,
              data = data)

  data.frame(x = data$x,
             y = model$fitted.values,
             indicator = data$indicator,
             xend = data$x,
             yend = data$y)

}
```


## Step 2: define ggproto

--

- what's the naming convention for the proto object?
- which aesthetics are required as inputs?
- where does the function from above go?





```{r StatXYMedians}
StatLmindicator <- ggplot2::ggproto("StatLmindicator",
                                      ggplot2::Stat,
                                      compute_panel = compute_panel_ols_ind,
                                      required_aes = c("x", "y", "indicator"),
                                      default_aes = ggplot2::aes(
                                        group = ggplot2::after_stat(indicator),
                                        color = indicator))

```


## Step 3: define geom_* function


--

- define the stat and geom for your layer





```{r geom_point_xy_medians} 
geom_lm_indicator <- function(mapping = NULL, data = NULL,
                                position = "identity", na.rm = FALSE,
                                show.legend = NA,
                                inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatLmindicator, # proto object from Step 2
    geom = ggplot2::GeomLine, # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```




## Step 4: Enjoy! Use your function


---




```{r enjoy_penguins}
ggplot(palmerpenguins::penguins) +
  aes(x = flipper_length_mm ) +
  aes(y = body_mass_g ) +
  geom_point() + 
  aes(color = species) +
  aes(indicator = species) +
  geom_lm_indicator()


ggplot(palmerpenguins::penguins) +
  aes(x = flipper_length_mm ) +
  aes(y = body_mass_g ) +
  geom_point() + 
  aes(color = species) +
  aes(indicator = species) +
  geom_lm_indicator(formula = y ~ x * indicator)

ggplot(palmerpenguins::penguins) +
  aes(x = flipper_length_mm ) +
  aes(y = body_mass_g ) +
  geom_point() + 
  aes(color = species) +
  aes(indicator = species) +
  geom_lm_indicator(formula = y ~ I(x^3) + I(x^2) + x + indicator)
```


### Explain: What will the in-facet behavior be?

```{r}
ggplot(palmerpenguins::penguins) +
  aes(x = flipper_length_mm ) +
  aes(y = body_mass_g ) +
  geom_point() + 
  aes(color = species) +
  aes(indicator = species) +
  geom_lm_indicator(formula = y ~ x + indicator) + 
  facet_wrap(~sex)
```

## Step 0: Use base ggplot2 to get the job done

```{r cars}
library(tidyverse)
library(gapminder)
gapminder %>%  
  filter(continent == "Americas") %>%  
  filter(year == 2002) %>%  
  select(country, pop) ->  
prep  

packcircles::circleProgressiveLayout(prep$pop,  
                                         sizetype = 'area') ->  
pack  

cbind(prep, pack) %>%
  mutate(id = row_number())


pack %>%  
  packcircles::circleLayoutVertices(npoints = 50) ->  
circle_outlines  


circle_outlines %>%  
  ggplot() +  
  aes(x = x, y = y) +  
  geom_polygon(colour = "black", alpha = 0.6) +  
  aes(group = id) +  
  aes(fill = factor(id)) +  
  geom_text(data = cbind(prep, pack),  
            aes(x, y, size = pop, label = country,  
                group = NULL, fill = NULL)) +  
  theme(legend.position = "none") +  
  coord_equal()
```







---

## Step 1: computation

- define computation that ggplot2 should do for you, before plotting
  - here it's computing a variable with labels for each observation
- test that functionality!

```{r}
# you won't use the scales argument, but ggplot will later
compute_panel_circle_pack <- function(data, scales){
 
  data %>%
    mutate(id = row_number()) ->
  data1
 
  if(is.null(data$area)){
    
    data1 %>% 
      mutate(area = 1) ->
    data1
    
  }
  
  data1 %>%  
    pull(area) %>%
    packcircles::circleProgressiveLayout(
                                         sizetype = 'area') %>%
    packcircles::circleLayoutVertices(npoints = 300) %>%
    left_join(data1) #%>%
    # rename(group = id)
   
}


# step 1b test the computation function
gapminder::gapminder %>%
  filter(continent == "Americas") %>%  
  filter(year == 2002) %>%  
  # input must have required aesthetic inputs as columns
  rename(area = pop) %>%
  compute_panel_circle_pack() %>%
  head()


gapminder::gapminder %>%
  filter(continent == "Americas") %>%  
  filter(year == 2002) %>%  
  # input must have required aesthetic inputs as columns
  rename(area = pop) %>%
  compute_panel_circle_pack() %>% 
  str()

# step 1b test the computation function
gapminder::gapminder %>%
  filter(continent == "Americas") %>%  
  filter(year == 2002) %>%  
  # input must have required aesthetic inputs as columns
  rename(area = pop) %>%
  compute_panel_circle_pack() %>% 
  ggplot() + 
  aes(x = x, y = y, fill = country) + 
  geom_polygon()

my_setup_data <- function(data, params){
                                    if(data$group[1] == -1){
                                      nrows <- nrow(data)
                                      data$group <- seq_len(nrows)
                                    }
                                    data
                                  }

```

---

## Step 2: define ggproto

- what's the naming convention for the proto object?
- which aesthetics are required as inputs?
- where does the function from above go?

```{r}
StatCirclepack <- ggplot2::ggproto(`_class` = "StatCirclepack",
                                  `_inherit` = ggplot2::Stat,
                                  required_aes = c("id"),
                                  compute_panel = compute_panel_circle_pack#,
                                  # setup_data = my_setup_data,
                                  # default_aes = aes(fill = after_stat(area))
                                  )
```


---

## Step 3: define geom_* function

```{r}
geom_polygon_circlepack <- function(mapping = NULL, data = NULL,
                           position = "identity", na.rm = FALSE,
                           show.legend = NA,
                           inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatCirclepack, # proto object from Step 2
    geom = ggplot2::GeomPoint, # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```



---

## Step 4: Enjoy! Use your function

```{r}
gapminder::gapminder %>%
  filter(year == 2002) %>%
  ggplot() +
  aes(id = country) + 
  geom_polygon_circlepack(alpha = .5, size = .002)

last_plot() + 
  aes(color = continent)

last_plot() + 
  aes(area = pop)

last_plot() +
  aes(color = continent) +
  facet_wrap(facets = vars(continent)) 

```


---

# Step 0: get it done with base ggplot2

# Example simple feature to data frame...

```{r}
library(tidyverse)
library(sf)

fips_geometries <- readRDS(url("https://wilkelab.org/SDS375/datasets/US_counties.rds")) %>%
  rename(FIPS = GEOID)

US_census <- read_csv("https://wilkelab.org/SDS375/datasets/US_census.csv",
                      col_types = cols(FIPS = "c")
          )

# from Claus Wilke on ggplot2

fips_geometries %>%
  left_join(US_census, by = "FIPS") %>%
  ggplot() +
  geom_sf(aes(fill = mean_work_travel), linewidth = .1) + 
  scale_fill_viridis_c(option = "magma") ->
classic_plot_sf_layer

classic_plot_sf_layer



```

# Step 1: computation


```{r}

layer_data(classic_plot_sf_layer) %>% 
  select(geometry, xmin, xmax, ymin, ymax) %>% 
  bind_cols(tibble(FIPS = fips_geometries$FIPS)) %>% 
  rename(fips = FIPS) ->
reference


compute_panel_county <- function(data, scales){
 
  data %>% 
    # inner_join(fips_ggplot2_reference) 
    inner_join(reference, multiple = "all") %>% 
    mutate(group = -1)

}


```


# Step 2: pass to ggproto

```{r}
StatCounty <- ggplot2::ggproto(`_class` = "StatCounty",
                                  `_inherit` = ggplot2::Stat,
                                  # required_aes = c("fips"),
                                  # setup_data = my_setup_data,
                                  compute_panel = compute_panel_county,
                                  default_aes = aes(geometry = after_stat(geometry))
                                  )
```


# Step 3: write geom_* function

```{r}
geom_sf_county <- function(
  mapping = NULL,
  data = NULL,
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE, ...) {
  ggplot2::layer(
    stat = StatCounty,  # proto object from step 2
    geom = ggplot2::GeomSf,  # inherit other behavior
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```

# step 4: test geom_* function, celebrate!

```{r, eval = T}
read_csv("https://wilkelab.org/SDS375/datasets/US_census.csv",
                      col_types = cols(FIPS = "c")) %>%  
  ggplot() + 
  aes(fips = FIPS) +
  geom_sf_county(linewidth = .02, 
                      color = "darkgrey") +
  aes(fill = mean_work_travel) + 
  coord_sf() +
  scale_fill_viridis_c(option = "magma")
```
